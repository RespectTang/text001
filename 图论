/*
8.同色三角形 (15分) 
题目内容：
 平面上有n个点（n≤8000），每两个点之间都有一条红色或者是黑色的线段，任意三点均不共线。
现在，已知哪些点之间连的线段是红色的，剩下的线段都是黑色的，要求计算这些点组成的三角
形中有多少是同色的（顶点编号从1到n）？
输入描述
第一行是n, m（3≤n≤8000），n表示点的个数，m表示红色线段的条数。下面m行，每
一行都是两个整数a和b，表示点a和点b之间的线段是红色的（a<b）。
输出描述
只有一行，表示同色三角形的个数。
提示：本题输出数据可能会超出长整数（long int）的范围。
输入样例
6 5  
1 2  
1 3
2 3
2 5
3 6
输出样例
7
*/ 
#include<stdio.h>
#define N 8001

int colorline[N][N]={0};//将所有线设为黑色

int main() 
{
	
	int n,m;//点的数目和红色线的条数 
	int x,y;//点的坐标
	int t=0;//记录同色三角形的个数
	int i,j,k; 
	
	scanf("%d%d",&n,&m);
	
	for(i=0;i<m;i++)
	{
		scanf("%d%d",&x,&y);//输入点的坐标 
		colorline[x][y]=colorline[y][x]=1;//1表示红色线
	 } 
	
	for(i=1;i<=n;i++)
		for(j=i+1;j<=n;j++)
			for(k=j+1;k<=n;k++)
			{
				if(colorline[i][j]==colorline[i][k]&&colorline[i][j]==colorline[j][k])
				t++;
			}
	
	printf("%d",t);

	return 0;
 } 

/****************************************************************************************************/
/*
8.数字三角形 (20分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
给定一个由n行数字组成的数字三角形，试设计一个算法，计算出从三角形的顶到底的一条路径，
使该路径经过的数字总和最大(输入时，这n行数字构成一个直角三角形，参见输入样例，计算路径时，
上面一个元素a只能选择下面一行中处于a正下方的b，或者b右边的元素c相连。反过来，
下面一个元素x,则只能跟正上面一个元素y, 或者y左边一个元素z相连）。
输入描述
第一行输入数字三角的行数n(0<n<100)，后面输入n行数字，每行元素个数递增,数据为100以内整数。
输出描述
输出最大值。
输入样例
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
输出样例
30
*/

#include<stdio.h>
int n;
int a[100][100];

int max(int p,int q)
{
	if(q>p)
	return q;
	else
	return p;
}

int m(int i,int j)
{
	int x,y;
	if(i==n)
		return a[i][j]; 

	x=m(i+1,j);
	y=m(i+1,j+1);
		return max(x,y)+a[i][j];
		
	
}

int main(int argc, char const *argv[])
{
	int i,j,k;
	
	scanf("%d",&n);
	
	for(i=1;i<=n;i++)
		for(j=1;j<=i;j++)
		{
			scanf("%d",&a[i][j]);
		}
		
	printf("%d",m(1,1));
	
	return 0;
}

/****************************************************************************************************/
/*
4.线数目 (15分) 
题目内容：
现有画有黑线（直线或曲线）的白底图片一张，计算出有多少条黑线、并依次输出每条黑线所占的点数。图片我们用0、1图表示
，1代表黑点 0 代表白点，某点周围8个方向都算连通，如下图所示，共有3条黑线，长度分别是5、3、5：
1 0 0 0 0 0 0
0 1 1 1 1 0 0
0 0 0 0 0 0 0
1 1 0 0 0 1 1
1 0 0 1 1 1 0
输入描述
图的宽w、高h，换行输入图的像素点.(测试数据结果唯一确定)
输出描述
黑线条数、换行输出每条线长度.（条数及每个长度各占一行）.
输入样例
7 5 
1 0 0 0 0 0 0
0 1 1 1 1 0 0
0 0 0 0 0 0 0
1 1 0 0 0 1 1
1 0 0 1 1 1 0
输出样例
3
5
3
5
*/
#include<stdio.h>
#define MAX 100
	int map[MAX][MAX]={0},b[MAX];
	int h,w,i,j,k=0;
int find(int i,int j)
{
	if(map[i][j]==1)
		{
			map[i][j]=0; 
			
			/*return find(i-1,j-1)+find(i-1,j)+
			find(i-1,j+1)+find(i,j-1)+
			find(i,j+1)+find(i+1,j-1)+
			find(i+1,j)+find(i+1,j+1)+1;*/
			return find(i-1,j-1)+find(i,j-1)+find(i+1,j-1)+find(i-1,j)+find(i+1,j)+find(i-1,j+1)+find(i,j+1)+find(i+1,j+1)+1;
		}
	else
		return 0;
}

int main()
{

	scanf("%d%d",&w,&h);
	
	for(i=1;i<=h;i++)
		for(j=1;j<=w;j++)
		{
			scanf("%d",&map[i][j]);
		 } 
	for(i=1;i<=h;i++)
		for(j=1;j<=w;j++)
		{
			int sum=find(i,j);
			if(sum!=0)
				b[k++]=sum;
		}
	printf("%d\n",k);
	
	for(i=0;i<k;i++)
	{
		printf("%d\n",b[i]);
	}
	
	return 0;
}







/****************************************************************************************************/



