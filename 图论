/*
8.同色三角形 (15分) 
题目内容：
 平面上有n个点（n≤8000），每两个点之间都有一条红色或者是黑色的线段，任意三点均不共线。
现在，已知哪些点之间连的线段是红色的，剩下的线段都是黑色的，要求计算这些点组成的三角
形中有多少是同色的（顶点编号从1到n）？
输入描述
第一行是n, m（3≤n≤8000），n表示点的个数，m表示红色线段的条数。下面m行，每
一行都是两个整数a和b，表示点a和点b之间的线段是红色的（a<b）。
输出描述
只有一行，表示同色三角形的个数。
提示：本题输出数据可能会超出长整数（long int）的范围。
输入样例
6 5  
1 2  
1 3
2 3
2 5
3 6
输出样例
7
*/ 
#include<stdio.h>
#define N 8001

int colorline[N][N]={0};//将所有线设为黑色

int main() 
{
	
	int n,m;//点的数目和红色线的条数 
	int x,y;//点的坐标
	int t=0;//记录同色三角形的个数
	int i,j,k; 
	
	scanf("%d%d",&n,&m);
	
	for(i=0;i<m;i++)
	{
		scanf("%d%d",&x,&y);//输入点的坐标 
		colorline[x][y]=colorline[y][x]=1;//1表示红色线
	 } 
	
	for(i=1;i<=n;i++)
		for(j=i+1;j<=n;j++)
			for(k=j+1;k<=n;k++)
			{
				if(colorline[i][j]==colorline[i][k]&&colorline[i][j]==colorline[j][k])
				t++;
			}
	
	printf("%d",t);

	return 0;
 } 

/****************************************************************************************************/
/*
8.数字三角形 (20分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
给定一个由n行数字组成的数字三角形，试设计一个算法，计算出从三角形的顶到底的一条路径，
使该路径经过的数字总和最大(输入时，这n行数字构成一个直角三角形，参见输入样例，计算路径时，
上面一个元素a只能选择下面一行中处于a正下方的b，或者b右边的元素c相连。反过来，
下面一个元素x,则只能跟正上面一个元素y, 或者y左边一个元素z相连）。
输入描述
第一行输入数字三角的行数n(0<n<100)，后面输入n行数字，每行元素个数递增,数据为100以内整数。
输出描述
输出最大值。
输入样例
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
输出样例
30
*/

#include<stdio.h>
int n;
int a[100][100];

int max(int p,int q)
{
	if(q>p)
	return q;
	else
	return p;
}

int m(int i,int j)
{
	int x,y;
	if(i==n)
		return a[i][j]; 

	x=m(i+1,j);
	y=m(i+1,j+1);
		return max(x,y)+a[i][j];
		
	
}

int main(int argc, char const *argv[])
{
	int i,j,k;
	
	scanf("%d",&n);
	
	for(i=1;i<=n;i++)
		for(j=1;j<=i;j++)
		{
			scanf("%d",&a[i][j]);
		}
		
	printf("%d",m(1,1));
	
	return 0;
}

/****************************************************************************************************/
/*
4.线数目 (15分) 
题目内容：
现有画有黑线（直线或曲线）的白底图片一张，计算出有多少条黑线、并依次输出每条黑线所占的点数。图片我们用0、1图表示
，1代表黑点 0 代表白点，某点周围8个方向都算连通，如下图所示，共有3条黑线，长度分别是5、3、5：
1 0 0 0 0 0 0
0 1 1 1 1 0 0
0 0 0 0 0 0 0
1 1 0 0 0 1 1
1 0 0 1 1 1 0
输入描述
图的宽w、高h，换行输入图的像素点.(测试数据结果唯一确定)
输出描述
黑线条数、换行输出每条线长度.（条数及每个长度各占一行）.
输入样例
7 5 
1 0 0 0 0 0 0
0 1 1 1 1 0 0
0 0 0 0 0 0 0
1 1 0 0 0 1 1
1 0 0 1 1 1 0
输出样例
3
5
3
5
*/
#include<stdio.h>
#define MAX 100
	int map[MAX][MAX]={0},b[MAX];
	int h,w,i,j,k=0;
int find(int i,int j)
{
	if(map[i][j]==1)
		{
			map[i][j]=0; 
			
			/*return find(i-1,j-1)+find(i-1,j)+
			find(i-1,j+1)+find(i,j-1)+
			find(i,j+1)+find(i+1,j-1)+
			find(i+1,j)+find(i+1,j+1)+1;*/
			return find(i-1,j-1)+find(i,j-1)+find(i+1,j-1)+find(i-1,j)+find(i+1,j)+find(i-1,j+1)+find(i,j+1)+find(i+1,j+1)+1;
		}
	else
		return 0;
}

int main()
{

	scanf("%d%d",&w,&h);
	
	for(i=1;i<=h;i++)
		for(j=1;j<=w;j++)
		{
			scanf("%d",&map[i][j]);
		 } 
	for(i=1;i<=h;i++)
		for(j=1;j<=w;j++)
		{
			int sum=find(i,j);
			if(sum!=0)
				b[k++]=sum;
		}
	printf("%d\n",k);
	
	for(i=0;i<k;i++)
	{
		printf("%d\n",b[i]);
	}
	
	return 0;
}







/****************************************************************************************************/
/*
7.矩形嵌套 
题目内容：
有n个矩形，每个矩形可以用a,b来描述，表示长和宽。矩形X(a,b)可以嵌套在矩形Y(c,d)中
当且仅当a<c,b<d或者b<c,a<d（相当于旋转X90度）。例如（1,5）可以嵌套在（6,2）内，但不能嵌套在（3,4）
中。你的任务是选出尽可能多的矩形排成一行，使得除最后一个外，每一个矩形都可以嵌套在下一个矩形内。
输入描述
第一行是一个正正数N(0<N<10)，表示测试数据组数，每组测试数据的第一行是一个正正数n，
表示该组测试数据中含有矩形的个数(n<=1000)随后的n行，每行有两个数a,b(0<a,b<100)，
表示矩形的长和宽
输出描述
每组测试数据都输出一个数，表示最多符合条件的矩形数目，每组输出占一行
输入样例
1
10
1 2         
2 4
5 8 
6 10
7 9
3 1
5 8
12 10
9 7
2 2
输出样例
5
*/ 

#include<stdio.h>
int main()
{
	int a[100],b[100],s[100]={0},c[100],d[100];//ab数组存储长宽
	int n,m;//n组测试数据，m组矩形
	int i,j,k,temp;
	
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&m);
		i=0;
		for(i=0;i<m;i++)
		{
			scanf("%d%d",&a[i],&b[i]);
			s[i]=a[i]*b[i];//计算面积 	
		}
		/*对面积进行排序 */
		for(i=1;i<=m-1;i++)
			for(j=0;j<m-i;j++)
			{
				if(s[j]>s[j+1])
				{
					temp=s[j];
					s[j]=s[j+1];
					s[j+1]=temp;
					
					temp=a[j];
					a[j]=a[j+1];
					a[j+1]=temp;
					
					temp=b[j];
					b[j]=b[j+1];
					b[j+1]=temp; 
					
				}
			}
			
				for(i=0;i<m;i++)
				{
					c[i]=a[i];
					d[i]=b[i];
				}
			
		k=0;
		for(i=0;i<m;i++)
		{
			for(j=i;j<m-i;j++)
			{
				if((a[i]<c[j+1]&&b[i]<d[j+1])||(b[i]<c[j+1]&&a[i]<d[j+1]))
				{
					k++;
					break;
				}
			}
		}
		printf("%d\n",k);
	 } 
	return 0;
}




