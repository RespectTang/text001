/*
8.极差 (15分) 
题目内容：
在黑板上写了N个正整数组成的一个数列，进行如下操作：每次擦去其中的两个数a和b，
然后在数列中加入一个数a*b＋1，如此下去直至黑板上剩下一个数，在所有按这种操作方式
最后得到的数中，最大的为max，最小的为min，则该数列的极差定义为M＝max－min.请你编程，
对于给定的数列，计算极差.
输入描述
输入包含多个测试集.每个测试集的第一行N表示正整数序列长度（0＜＝N＜＝50000），随后第二行是N个正整数.当N为0时结束.
输出描述
每个结果一行.
输入样例
3
3 5 7
输出样例
4
*/
#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;
const int N=50000;//32位编译器最大值

bool cmp(const int i,const int j)
{
	return i>j;//定义降序排序 
 } 

int main()
{
	int n,i;
	int a[100],b[100];
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
		b[i]=a[i];
	}
	
	int tn=n;
	while(tn>1)
	{
		sort(a,a+n);
		a[1]=a[0]*a[1]+1;
		a[0]=N;
		tn--;
	}
	int max=a[1];
	tn=n;
	while(tn>1)
	{
		sort(b,b+n,cmp);
		b[1]=b[0]*b[1]+1;
		b[0]=0;
		tn--;
	}
	int min=b[1];
	cout<<abs(max-min);
	return 0;
 } 

/**************************************************************************************************************************/
/*
9. 带分数 (15分)
题目内容：
100 可以表示为带分数的形式：100 = 3 + 69258 / 714
还可以表示为：100 = 82 + 3546 / 197
注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。
类似这样的带分数，100 有 11 种表示法。
题目要求：
从标准输入读入一个正整数N (N<1000*1000)
程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。
注意：不要求输出每个表示，只统计有多少表示法！
输入描述
从标准输入读入一个正整数N (N<1000*1000)
输出描述
程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。
输入样例
100
输出样例
11
*/ 
#include<iostream>
#include<algorithm>
using namespace std;
int p[9];
int cnt[1000005];
int main()
{
	for(int i=0;i<9;i++)
		p[i]=i+1;
	int a,b,c,ans;
	do{

		for(int i=0;i<=6;i++)
			for(int j=i+1;j<=7;j++)
			{
				a=0;
				b=0;
				c=0;
				ans=0;
				for(int k=0;k<=i;k++)
					a=a*10+p[k];
				for(int k=i+1;k<=j;k++)
					b=b*10+p[k];
				for(int k=j+1;k<=8;k++)
					c=c*10+p[k];
				if(b%c==0)
					{
					ans=a+b/c;
					if(ans<1000000)
					cnt[ans]++;
					}

			}

	}
	while(next_permutation(p,p+9));
		int n;
		cin>>n;
		cout<<cnt[n];

}


/*
思路：
首先，这个题用暴力枚举一定会超时的，所以我就没试。
为何暴力枚举会超时？
原因在于，暴力枚举会搜索到很庞大的没有用的数据，最后在十几万甚至几百万个组合中，也许仅仅只有十几种
组合符合条件，这就大大的浪费了时间。想要避免这类事件的发生，就要有好的剪枝条件。
如何建造好的剪枝条件？
本题说的是，n=a+b/c；那么首先a一定是小于n的，又因为n为整数，所以a和b/c都是整数，这就要求
b/c一定可以整除，所以b%c=0，b/c还要满足可除条件，即b>=c。剪枝的三个条件已经确定
(1).a<n；
(2).b%c=0；
(3).b>=c
再加上n=a+b/c就是四个条件了。只要在1至9的全排列中选取满足这四个条件的全排列就是所求的结果之一。
那么在1至9的全排列（9个数字）中如何确定a，b，c的取值范围呢？
a前面已经说过，而又知道，b一定大于或等于c，则b的取值范围一定在a选择过后去选择剩下的一半或一半以上的数据。举个例子，1至9的其中一个全排列--156987423，若a选择156，则b只能选择剩下的987423中的一半或
一半以上，如987、9874、98742。如果b小于剩下的一半，那么一定不满足除法（如98/7432）。c
的范围则是a和b选择剩下的所有了。这样我们就可以判定，假设num=9，a选择9位中的前n位，那
么b的结尾选择范围为第n+（num-n）/2至num-1位数字（结尾为一半或一半以上，最多时到num-1
，给c留一个数字）；
那么利用深度优先搜索（用来得到一个9位的全排列）和适当的判断（剪枝，找出符合3个条件并
且满足n=a+b/c的全排列）就可以解决。
AC代码：

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<time.h>
int aws=0;
int a[10],flag[10];
int sum(int start,int end)
{
	int i,sum=0; 
	for(i=start;i<end;i++)
	sum=sum*10+a[i+1]; 
	return sum;
}
void Found(int a[],int n,int m)//将DFS中的每一个全排列结果放在Found函数中检验
{
	int i,j,begin=0;
	for(i=1;i<n;i++)
	{
		int m1=sum(0,i);//第一个数从1至9开始选?
		if(m1>=m) return;//不满足第一个数<m的直接淘汰?
		for(j=i+(n-i)/2;j<n-1;j++)
		{
			int m2=sum(i,j);//第二个数?
			int m3=sum(j,n-1);//第三个数?
			if(m2>m3&&m2%m3==0&&m==m1+m2/m3)
			{
				aws++;
			}
		}
	}
}
void DFS(int start,int n,int m)//对1~9进行全排列?
{
	int i;
	if(start==n)
	Found(a,n,m);
	else
	{
		for(i=1;i<n;i++)
		{
			if(flag[i])
			 continue; 
			a[start]=i; 
			flag[i]=1; 
			DFS(start+1,n,m);//选择好一位开始选下一位
			flag[i]=0;
		}
	}
}
int main()
{
	int i,j,m;
	double s1,s2;
	memset(flag,0,sizeof(flag));
	scanf("%d",&m);
	DFS(1,10,m);
	printf("%d\n",aws);
	return 0;
}
检测100所用的时间： 


100
100=3+69258/714
100=81+5643/297
100=81+7524/396
100=82+3546/197
100=91+5742/638
100=91+5823/647
100=91+7524/836
100=94+1578/263
100=96+1428/357
100=96+1752/438
100=96+2148/537
11
420ms
*/

/**************************************************************************************************************************/
/*
9.完美数 (15分) 
题目内容：
如果有一正整数n，其真因数的总和等于n，则称之为完美数。
例如以下几个数都是完美数：
6=1+2+3
28=1+2+4+7+14
496=1+2+4+8+16+31+62+124+248
求小于n的所有完美数.
输入描述
输入一个正整数n
输出描述
输出小于n的完美数，按升序输出，每个数据占一行
输入样例
10
输出样例
6
*/
#include<stdio.h>
int main()
{
	int n,N;
	int i,j,k,sum;
	scanf("%d",&N);
	for(n=2;n<=N;n++)
	{
		sum=0;
		for(i=1;i<n;i++)
		{
			if(n%i==0)
				sum=sum+i;
		}	
		if(sum==n)
			printf("%d\n",n);	
	}
	
	return 0;
}
/**************************************************************************************************************************/
/*
最大k乘积问题
http://blog.csdn.net/qq_27601815/article/details/52938608
题目内容：
设I是一个n位十进制整数.如果将I划分为k段,则可得到k个整数.这k个整数的乘积称为I的一个k乘积.
试设计一个算法,对于给定的I和k ,求出I的最大k乘积.
Input
输入的第1行中有2个正整数n和k.正整数n是序列的长度;正整数k是分割的段数.接下来的一行中是一个
n位十进制整数.（n<=10）
Output
输出计算结果，第1行中的数是计算出的最大k乘积.
n位十进制整数.（n<=10）
输入样例
2 1
15
输出样例
15
*/
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
const int M=11;
int nik[M][M];
int dp[M][M];

int main()
{
	int ws,k;
	int n;
		scanf("%d%d",&ws,&k);//ws为位数 
		scanf("%d",&n);
		memset(dp,0,sizeof(dp)); 
		if(k==1)
		{
			printf("%d\n",n);
		}
		else
		{
			for(int i=1;i<=ws;i++)
			{
				int p=10;
				for(int j=i;j<=ws;j++)
				{
					nik[i][j]=n%p;//将n位十进制数按照不同段存储于nik二维数组中 ，例如将45678分别存储为8 78 678 5678 45678 
					p*=10;
				}
				n/=10;//将每一排 遍历所有的存储，第一排由1位8开始，第二排由二位78开始 ，以此类推至最后 
			}
			
		for(int i=1;i<=ws;i++)
		{
			dp[i][1]=nik[1][i];// 将nik第一排的数字存储至竖列 
		}
		for(int i=2;i<=k;i++)//填表式相乘 
		{
			for(int j=1;j<=ws;j++)
			{
				int maxn=0;
				for(int k=1;k<j;k++)
				{
				maxn=max(dp[k][i-1]*nik[k+1][j],maxn);//dp[j][i]中存储这种分割组合中的相乘结果，并按顺序排序 
				}
	
			dp[j][i]=maxn;
			}
		}
		printf("%d\n",dp[ws][k]);//最后dp[ws][k]即最后一格填表为最大值 
		}
	return 0;
}

/**************************************************************************************************************************/
/*
5.2-6 数列求和 (20分) 
题目内容：
给定某数字A（1<=A<=9）以及非负整数N（0<=N<=100000），
求数列之和S = A + AA + AAA + … + AA…A(N个A)。例如A=1, N=3时，
S = 1 + 11 + 111 = 123。
输入描述
输入数字A与非负整数N。
输出描述
输出其N项数列之和S的值。
输入样例
序号	输入	
1	1 3	
2	6 100	
3	1 0	
输出样例
序号 输出
1    123
2  7407407407407407407407407407407407407407407407407407407407407407407407407407407407407407407407407340
3     0
*/ 

#include<stdio.h>
int main()
{
	int q,n,i,j,k,lenb,m;
	char a[10000]={0},b[10000]={0},c[10000]={0};
	scanf("%d%d",&q,&n);
	
	if(n==0)
	{
	printf("%d",n);		
	}
	else
	{
		for(i=1;i<=n;i++)
		{
			for(j=0;j<=i;j++)//输入每一个数字,每一个数字都是i个长度 
			{
				a[j]=q;
			//	printf("ok\n");
			}
			for(j=0;j<i;j++)
			{
				b[j]+=a[j];
				if(b[j]>9)
				{
					b[j]=b[j]%10;
					b[j+1]++;
				}
			}
			b[i]='\0';
		}
		
		for(i=10000;(i>=0)&&(b[i]==0);i--);//从最高位找出不是零的数字输出 
		if(i>=0)
		{
			for(;i>=0;i--)
			printf("%d",b[i]);
		}	
	}

	return 0;	
}
/**************************************************************************************************************************/
/*
7.寻找最大数 
题目内容：
请在整数 n 中删除m个数字, 使得余下的数字按原次序组成的新数最大，
比如当n=92081346718538，m=10时，则新的最大数是9888
输入描述 
第一行输入一个正整数T，表示有T组测试数据每组测试数据占一行，每行有两个数n,m
（n可能是一个很大的整数，但其位数不超过100位，并且保证数据首位非0，m小于整数n的位数）
输出描述
每组测试数据的输出占一行，输出剩余的数字按原次序组成的最大新数
输入样例
2
92081346718538 10
1008908 5
输出样例
9888
98
*/
#include<stdio.h>
#include<string.h> 
int main()
{
	int n,m;
	int i,j,k,len,max,p,q,num;
	char s[100],a[100];
	scanf("%d",&n);
	while(n--)
	{	
		memset(s,'\0',sizeof(s));//动态内存分配 
		scanf("%s %d",s,&m);
		len=strlen(s);
		num=len-m;
		j=0;
		max=0;
		memset(a,'\0',sizeof(a));
		while(num--)
		{
			for(i=max+1;i<len-num;i++)//从左往右找最大的数，这一次找时从上次找到的最大数的下一位开始找
			{
				if(s[i]>s[max])
				max=i;
			}
		a[j++]=s[max];
		max=max+1;	
		}
		
		for(i=0;i<j;i++)
		printf("%c",a[i]);	
		printf("\n");
	}
	
	return 0;
 } 
/**************************************************************************************************************************/
/*
题目内容：
YF不爱名利，所以他既不喜欢6，也不喜欢8。他的幸运数字是4和7。如果一个数字中只包含4和7，他就认为这个数字是他的幸运数。
现在给你两个正整数a,b，要求返回a,b之间的幸运数的个数，包括a,b本身。
输入描述
第一行输入数目n,表示后面有n组ab
第2行开始，每行一组a b, 空格隔开。
输出描述
每行输出一个数，即a,b之间的幸运数的个数。
输入样例
3
11 20
4 7
1 10
输出样例
0
2
2
*/
#include <stdio.h>
int b[10000];
int fun(int a)//判断是否为幸运数字 
{
	int m,n,i,j,t=0,b[10000];
	for(n=a,i=0;n!=0;i++)
	{
		m=n%10;
		n=n/10;
		b[i]=m;
	}
	for(j=0;j<i;j++)
	{
		if(b[j]!=4&&b[j]!=7)
		{
			t=0;
			break;
		}
		else
		t=1;
	}
	return t; 
}
int main()
{
    int n,a,b,sum[10000];
	int i,j;
	scanf("%d",&n);//输入数目n 
	for(i=0;i<n;i++)
	{
		scanf("%d%d",&a,&b);//输入区间a,b 
		sum[i]=0;//记录每个区间的个数 
		for(j=a;j<=b;j++)
		{
			sum[i]+=fun(j);
		}
	}
	for(i=0;i<n;i++)
		printf("%d\n",sum[i]);
	return 0;
}
/**************************************************************************************************************************/
/*
17.约瑟夫环 (5分) 
题目内容：
有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的
人退出圈子，问最后留下的是原来第几号的那位?
输入描述
正整数n
输出描述
直接输出结果
输入样例
10
输出样例
4
*/

#include<stdio.h>
int main()
{
	int n,i,k,j,str[100]={0},*p;
	scanf("%d",&n);
	p=str;
	for(i=0;i<n;i++)
	p[i]=i+1;

	i=0;
	j=1;
	k=0;
	int all=n;
	while(n>0)
	{
		if(i>=all)
		i=i%all;
		
		if(p[i]!=0)
		{
			if(j==3)//如果遇到3就退出 
			{
				k=i+1;
			//	printf("%d\n",i+1);
				p[i]=0; 
				j=1;//j从1开始重新计数
				i++;
				n--;//总人数减一 
			
			}
			else//如果j不是3就继续 
			{
				i++;
				j++;
			}
		}
		else
		i++;
	}
	printf("%d",k);
	return 0;
}
/**************************************************************************************************************************/
/*题目内容：
对于一个正整数n的划分，就是把n变成一系列正整数之和的表达式。注意，分划与顺序无关，例如6=5+1跟6=1+5是
同一种分划。另外，单独这个整数本身也算一种分划。
例如：对于正整数n=5，可以划分为：
1+1+1+1+1
1+1+1+2
1+1+3
1+2+2
2+3
1+4
5
输入描述
输入一个正整数n
输出描述
输出n整数划分的总数k
输入样例
5
输出样例
7
*/

#include<stdio.h>
#include<iostream>
using namespace std;

int equationCount(int n,int m)
{
    if(n==1||m==1)
        return 1;
    else if(n<m)
        return equationCount(n,n);
    else if(n==m)
        return 1+equationCount(n,n-1);
    else
        return equationCount(n,m-1)+equationCount(n-m,m);
}

int main(void)
{
    int n;
    if(scanf("%d",&n)!=EOF&&(n>=1&&n<=120))
    
        printf("%d\n",equationCount(n,n));
    
    return 0;
}

/*
f(n, m)= 1; (n=1 or m=1) 
f(n, m)=f(n, n); (n<m) 
1+ f(n, m-1); (n=m) 
f(n-m,m)+f(n,m-1); (n>m) 
*/
/**************************************************************************************************************************/
/*
1001. 害死人不偿命的(3n+1)猜想 (15)
时间限制 
400 ms
卡拉兹(Callatz)猜想：
对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。
这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，
传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，
以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 
我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？ 
输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。
输出格式：输出从n计算到1需要的步数。
输入样例：
3
输出样例：
5
*/ 
#include<stdio.h>
int main()
{
	int i,j,k=0;
	int n;
	scanf("%d",&n);
	while(n!=1)
	{
		if(n%2==1)
			n=(3*n+1)/2;
		else
			n=n/2;
		k++;	
	}
	printf("%d",k);
	return 0;
}
/**************************************************************************************************************************/
/*
1005. 继续(3n+1)猜想 (25)
时间限制 
400 ms
卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。
当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，
我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，
因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，
如果n不能被数列中的其他数字所覆盖。现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。
你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。
输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(<100)，第2行给出K个互不相同的待验证的正整数n(1<n<=100)的值，
数字间用空格隔开。
输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。
输入样例：
6
3 5 6 7 8 11
输出样例：
7 6
思路：
我们可以将其用标记数组的形式存起来 
例如 7这个数，我们让x[7]=1 ，而不是让x[i]=7,这样做可以方便后续的处理， 
并且因为数据规模小于100，所以x数组大小只要大于101就可以了。 
然后从后向前从大到小扫描x数组，若遇上x[i]=1的，则对i进行题目所说的操作。 
并且对操作中出现的所有数a 使该数的x[a]为0， 
最后从大到小扫描一遍x数组，将x数组中剩下的x[i]为1的值输出就是答案 
*/ 
#include<iostream>
#include<algorithm>
#include<stdlib.h>
using namespace std;

int x[200]={0};
int half(int a)
{
	int count=1;
	while(a>1)
	{
		if(a%2==1)
			a=(a*3+1)/2;
		else
			a/=2;
		if(a<200)
			x[a]=0;//标记被覆盖数组 
	 } 
	 return count; 
}

int main()
{
	int n,in;
	int i,j,k;
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>in;
		x[in]=1;
	}
	
	for(i=101;i>=0;i--)
	{
		if(x[i])
			half(i);
	}
	
	int flag=1;
	for(i=101;i>=0;i--)
	{
		if(x[i])//符合题目输出格式 
		{
			if(flag)
			{
				cout<<i;
				flag=0;
			 } 			
			else
				cout<<' '<<i;			
		}
	}
	return 0;
}
/**************************************************************************************************************************/
/*
1010. 一元多项式求导 (25)
时间限制 
400 ms
内存限制 
65536 kB
代码长度限制 
8000 B
判题程序 
Standard 
设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）
输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。
输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。
注意“零多项式”的指数和系数都是0，但是表示为“0 0”。
输入样例：
3 4 -5 2 6 1 -2 0
输出样例：
12 3 -10 1 6 0
*/ 
#include<stdio.h>  
  
int main()  
{  
    int a[1001],b[1001],i,j;  
    for(i=0;i<1001;i++)  
    {  
        scanf("%d %d",&a[i],&b[i]);  
        if(b[i]==0)  
        break;    
    }  
    for(j=0;j<=i;j++)  
    {  
        if(a[j]==0||b[j]==0)  
        {  
            printf("0 0\n");      
        }  
        else  
        {  
            printf("%d %d",a[j]*b[j],b[j]-1);  
            if(j==i-1)  
            {  
                printf("\n");  
                break;    
            }  
            else  
            printf(" ");  
        }     
    }  
}   

/**************************************************************************************************************************/
/*
1011. A+B和C (15)
时间限制 
150 ms
内存限制 
65536 kB
代码长度限制 
8000 B
判题程序 
Standard 
作者 
HOU, Qiming
给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。 
输入格式： 
输入第1行给出正整数T(<=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。
输出格式： 
对每组测试用例，在一行中输出“Case #X: true”如果A+B>C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。
输入样例：
4
1 2 3
2 3 4
2147483647 0 2147483646
0 -2147483648 -2147483647
输出样例：
Case #1: false
Case #2: true
Case #3: true
Case #4: false
*/ 
#include<iostream>
using namespace std;
int n;
int i,j,k;
long long int a[1000],b[1000],c[1000];
int result[1000]={0};

int main()
{
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>a[i]>>b[i]>>c[i];
		if(a[i]+b[i]>c[i])
			result[i]=1;
	}
	for(i=0;i<n;i++)
	{
		if(result[i]==1)
			cout<<"Case #"<<i+1<<": true"<<endl;
		else
			cout<<"Case #"<<i+1<<": false"<<endl;
	}
	return 0;
}
/**************************************************************************************************************************/
/*
1016. 部分A+B (15)
正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，
则A的“6部分”PA是66，因为A中有2个6。
现给定A、DA、B、DB，请编写程序计算PA + PB。
输入格式： 
输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 < A, B < 1010。
输出格式： 
在一行中输出PA + PB的值。 
输入样例1：
3862767 6 13530293 3
输出样例1：
399
输入样例2：
3862767 1 13530293 8
输出样例2：
0
*/ 
#include<iostream>
using namespace std;
int  a[100],b[100];
int A,B;
int da,db;

int main()
{
	cin>>A>>da>>B>>db;
	int i,j,k;
	int pa=0,pb=0;
	for(i=0;A!=0;i++)
	{
		a[i]=A%10;
		if(a[i]==da)
		{
			pa=pa*10+a[i];
		}
		A/=10;
	}
	for(i=0;B!=0;i++)
	{
		b[i]=B%10;
		if(b[i]==db)
		{
			pb=pb*10+b[i];
		}
		B/=10;
	}
	
	cout<<pa+pb<<endl;
	
	return 0;
}
/**************************************************************************************************************************/
/*
1017. A除以B (20)
本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。
输入格式： 
输入在1行中依次给出A和B，中间以1空格分隔。 
输出格式： 
在1行中依次输出Q和R，中间以1空格分隔。 
输入样例：
123456789050987654321 7
输出样例：
17636684150141093474 3
*/

#include<iostream>
#include<string.h>
using namespace std;

int main()
{
	char A[1001];
	int B;
	int n=0,flag=0,temp=0;
	scanf("%s%d",A,&B);
	n=strlen(A);
	int i;
	
	for(i=0;i<n;i++)
	{
		temp=(A[i]-'0')+temp*10;
		if(temp>=B)
		{
			printf("%d",temp/B);
			flag=1;
		}
		else if(flag)
				printf("0");
		temp=temp%B;		
	}
	if(!flag)
		printf("0");
	printf(" %d",temp);	
	return 0;
}
/**************************************************************************************************************************/
/*
1019. 数字黑洞 (20)
给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，
将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。
例如，我们从6767开始，将得到
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174
... ...
现给定任意4位正整数，请编写程序演示到达黑洞的过程。
输入格式： 
输入给出一个(0, 10000)区间内的正整数N。 
输出格式： 
如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。
注意每个数字按4位数格式输出。 
输入样例1：
6767
输出样例1：
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
输入样例2：
2222
输出样例2：
2222 - 2222 = 0000
*/ 

#include<iostream>
#include<algorithm>
using namespace std;
int inc,de;
void fun(int x)
{
	int a[4];
	a[0]=x/1000;
	a[1]=x/100%10;
	a[2]=x/10%10;
	a[3]=x%10;
	sort(a,a+4);
	inc = a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3];  
    de = a[3] * 1000 + a[2] * 100 + a[1] * 10 + a[0];  
}

int main()
{
	int n,s;
	cin>>n;
	if ((n / 1000 == n / 100 % 10) && (n / 1000 == n / 10 % 10) && (n / 1000 == n % 10)){  
        printf("%04d - %04d = 0000\n", n, n);  
        return 0;  
    } 
    do{  
        fun(n);  
        s=de-inc;  
        printf("%04d - %04d = %04d\n", de, inc, s);  
        n=s;  
    } while (s!=6174);  
    return 0;  
	
}
/**************************************************************************************************************************/
/*
1021. 个位数统计 (15)
给定一个k位整数N = dk-1*10k-1 + ... + d1*101 + d0 (0<=di<=9, i=0,...,k-1, dk-1>0)，请编写程序统计每
种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。
输入格式： 
每个输入包含1个测试用例，即一个不超过1000位的正整数N。
输出格式： 
对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。
输入样例：
100311
输出样例：
0:2
1:3
3:1
*/
#include<iostream>
using namespace std;

int main()
{
	char s[1001];
	int a[10]={0};
	gets(s);
	int i,j,k;
	for(i=0;s[i]!='\0';i++)
	{
		a[s[i]-'0']++;
	}
	
	for(j=0;j<10;j++)
	{
		if(a[j]!=0)
		{
			cout<<j<<":"<<a[j]<<endl;
		}
	}
	
	
	return 0;
}
/**************************************************************************************************************************/
/*
1012. 数字分类 (20)
时间限制 
100 ms
内存限制 
65536 kB
代码长度限制 
8000 B
判题程序 
Standard 
作者 
CHEN, Yue
给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：
A1 = 能被5整除的数字中所有偶数的和； 
A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4...； 
A3 = 被5除后余2的数字的个数； 
A4 = 被5除后余3的数字的平均数，精确到小数点后1位； 
A5 = 被5除后余4的数字中最大数字。 
输入格式： 
每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。
输出格式： 
对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。
若其中某一类数字不存在，则在相应位置输出“N”。
输入样例1：
13 1 2 3 4 5 6 7 8 9 10 20 16 18
输出样例1：
30 11 2 9.7 9
输入样例2：
8 1 2 4 5 6 7 9 16
输出样例2：
N 11 2 N 9
*/
#include<iostream>  
#include<cstdio>  
using namespace std;  
/* 
 *思路： 
 *将5种情况分别求解即可 
 *注意点1:A2的和最后可能是0，所以不能通过判断结果是否为0判断是否输出N 
 *解决办法：各设置一个标志变量，计数符合某种情况的数字的个数，个数为0则输出N 
 * 
 */  
int main(){  
    int A1=0,A1t=0,A2=0,A2t=0,A3=0,A3t=0,A4t=0,A5=0,A5t=0,n;  
    double A4=0;  
    scanf("%d",&n);  
    int q = -1;  
    for(int i=0 ;i<n ;i++){  
        int x;  
        scanf("%d",&x);  
        if(x%10==0){  
            A1t++;  
            A1 += x;  
        }  
        if(x%5==1){  
            A2t++;  
            q = -q;  
            A2 += x*q;  
        }  
        if(x%5==2){  
            A3++;  
        }  
        if(x%5==3){  
            A4t ++;  
            A4 += x;  
        }  
        if(x%5==4){  
            A5t++;  
            if(x>A5){  
                A5 = x;  
            }  
        }  
  
    }  
    if(A1t!=0){  
        printf("%d ",A1);  
    }else{  
        printf("%s ","N");  
    }  
  
    if(A2t!=0){  
        printf("%d ",A2);  
    }else{  
        printf("%s ","N");  
    }  
  
    if(A3!=0){  
        printf("%d ",A3);  
    }else{  
        printf("%s ","N");  
    }  
  
    if(A4t!=0){  
        printf("%.1f ",A4/A4t);  
    }else{  
        printf("%s ","N");  
    }  
  
    if(A5t!=0){  
        printf("%d\n",A5);  
    }else{  
        printf("%s\n","N");  
    }  
    return 0;  
}  
/**************************************************************************************************************************/
/*
1022. D进制的A+B (20)
输入两个非负10进制整数A和B(<=230-1)，输出A+B的D (1 < D <= 10)进制数。 
输入格式： 
输入在一行中依次给出3个整数A、B和D。 
输出格式： 
输出A+B的D进制数。 
输入样例：
123 456 8
输出样例：
1103
*/


#include<iostream>
using namespace std;
int main()
{
	int a,b,d;
	int i=0,j,k;
	int s[100];
	int sum;
	cin>>a>>b>>d;
	sum=a+b;
//	cout<<sum<<endl; 
	do
	{
		s[i++]=sum%d;
		sum=sum/d;
	}while(sum!=0);
	//s[i]=sum;
	
	for(j=i-1;j>=0;j--)
	{
		cout<<s[j];
	}
	
	return 0;
}
/**************************************************************************************************************************/
/*
1023. 组个最小数 (20)
给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）
。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。 
现给定数字，请编写程序输出能够组成的最小的数。
输入格式： 
每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。
整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。 
输出格式： 
在一行中输出能够组成的最小的数。 
输入样例：
2 2 0 0 0 3 0 0 1 0
输出样例：
10015558
*/
#include <iostream>
using namespace std;
 int main()
  {
    int a[10];
    int i;
     for( i = 0; i < 10; i++ ) {
         scanf( "%d", &a[i] );
     }
 
     int min;
     for( i = 0; i < 10; i++ ) {
         if( i != 0 && a[i] != 0 ) {
             min = i;
             break;
         }
     }
     printf( "%d", min );
     a[min]--;
     for( i = 0; i < 10; i++ ) {
         for( ; a[i] > 0; a[i]-- ) {
             printf( "%d", i );
         }
     }
     return 0;
 }
/**************************************************************************************************************************/
/*
1024. 科学计数法 (20)
科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式[+-][1-9]"."[0-9]+E[+-][0-9]+，
即数字的整数部分只有1位，小数部分至少有1位，该数字及其指数部分的正负号即使对正数也必定明确给出。
现以科学计数法的格式给出实数A，请编写程序按普通数字表示法输出A，并保证所有有效位都被保留。
输入格式： 
每个输入包含1个测试用例，即一个以科学计数法表示的实数A。该数字的存储长度不超过9999字节，且其指数的绝对值不超过9999。
输出格式： 
对每个测试用例，在一行中按普通数字表示法输出A，并保证所有有效位都被保留，包括末尾的0。
输入样例1：
+1.23400E-03
输出样例1：
0.00123400
输入样例2：
-1.2E+10
输出样例2：
-12000000000
*/ 

#include<iostream>
#include<cstring> 
using namespace std;
int main()
{
    string a;
    char b[100000];
    cin>>a;
    int j=0;
    int behind_E_plus=0;        //保存E+之后所有字符所代表数字 
    int behind_E_minus=0;       //保存E-之后所有字符所代表数字 

    int  e=0;
    for(int i=0;i<a.length();i++)  //计算 E+，E-之后所有字符所代表数字 
    {
        if(e==1)
        {
            behind_E_plus=behind_E_plus*10+(a[i]-'0');
        }
        if(e==2)
        {
            behind_E_minus=behind_E_minus*10+(a[i]-'0');
        }
        if(a[i-1]=='E'&&a[i]=='+')  e=1;
        if(a[i-1]=='E'&&a[i]=='-')  e=2;
    }
    if(behind_E_minus!=0)           //分析是E-的情况 
    {
        for(int i=0;i<behind_E_minus;i++)  //在b数组中添加behind_E_minus个0 
        {
            b[j++]='0';
        }
        for(int i=0;i<a.length();i++)  //再添加原字符串E之前纯数字 
        {
            if(a[i]=='E') break;
            if(a[i]>='0'&&a[i]<='9')
            b[j++]=a[i];
        }
        for(int i=1;i<j;i++)        //输出，如果原字符串开头有-加上 
        {                           
	        if(i==1&&a[0]=='-')
	        cout<<"-";
	        if(i==1)
	        cout<<b[0]<<".";            //第一个元素之后家小数点 
	        cout<<b[i];
        }
    }
    else                            //如果输入的是E+的情况 
    {
        int count;                    //记录小数点之后有多少位 
        bool begin=false;             //是否开始记录小数点之后有多少位 
        for(int i=0;i<a.length();i++) //算出小数点之后E之前有多少位以及在b数组中保存原字符串纯数字 
        {                                       
            if(a[i]=='E') break;
            if(begin) count++;		//计算E之前的纯数字并存入b数组，count记录小数点之后的数字位数 
            if(a[i]=='.')  begin=true; 
            if(a[i]>='0'&&a[i]<='9')
            {
                b[j++]=a[i];
            } 
        }       //在最后添加0，若behind_E_plus<=count则不用添加 
        for(int i=0;i<behind_E_plus-count;i++)
        {
            b[j++]='0';
        }   
        if(behind_E_plus-count<0) //如果behind_E_plus<count，先输出behind_E_plus+1
        {                           //个元素，然后输出小数点，再输出剩下的元素          
            if(a[0]=='-')
            cout<<"-";
            int k=0;
            for(int i=0;i<(behind_E_plus)+1;i++)
            {
                cout<<b[i];
                k=i;
            }
            cout<<".";
            for(int i=k+1;i<j;i++)
            {
            cout<<b[i];
            }
        }       
        else        //如果behind_E_plus>=count则不用输出小数点 
        {
            for(int i=0;i<j;i++)
            {
                if(i==0&&a[0]=='-')
                cout<<"-";
                cout<<b[i];
            }
        }               

    }
    return 0;
}
/**************************************************************************************************************************/
/*
1030. 完美数列(25)
时间限制 
300 ms
内存限制 
65536 kB
代码长度限制 
8000 B
判题程序 
Standard 
作者 
CAO, Peng
给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M <= m * p，则称这个数列是完美数列。 
现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。
输入格式： 
输入第一行给出两个正整数N和p，其中N（<= 105）是输入的正整数的个数，p（<= 109）是给定的参数。第二行给出N个正整数，每个数不超过109。 
输出格式： 
在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。 
输入样例：
10 8
2 3 20 4 5 1 6 7 8 9
输出样例：
8
思路：首先p与最小数相乘可能会超出int范围，所以这里用double,其次我们应该先将数组排序以方便计算，然后我们用双重for循环查找，
查找的思路是从第一个元素作为最小数，开始往后找最大数，直到不符合条件，记录下此时的长度，然后将第二个元素作为最小数，再继续找，
最后比较长度的最大值并输出，但是这样会超时，所以我们要对她进行优化，减少不必要的循环，优化的思路如下：
首先我们同样保持第一个for循环遍历最小值，在第二个for循环中我们将j置为前一个元素作为最小数时候的长度，这样就减少了小于上一次的
不必要的for循环，j依然小于 N，用一个if判断是否符合条件，用另一个if判断此次是否大于上次的长度，比如说我们把样例中的数据已经排好序：
1 2 3 4 5 6 7 8 9 20 ，此时我们将array[0]作为最小数，依次向后遍历，最大数j-最小数i+1即为数列的长度，最终找到8为最大的数，此时数列
长度count为8，在将a[1]作为最小数的时候，我们直接将j置为1+8为9，直接比较a[1]和a[9]作为最小最大值得时候是否满足，不满足则a[1]最为最
小数的时候并不能使数列变得更长，则继续再看a[2],这样等到有大于8的时候再更新，就可以了
*/

#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
	int N,count=0;
	int i,j,k;
	long long int p,array[100010];
	cin>>N>>p;
	
	for(i=0;i<N;i++)
	{
		cin>>array[i];
	}
	
	sort(array,array+N);
	for(i=0;i<N;i++)//遍历，将a[i]作为最小数 
	{
		for(j=i+count;j<N;j++)///j置为要满足可以更新数列长度的值，减少循环次数 
		{
			if(array[j]>p*array[i])
			{
				break;
			}
			if(j-i+1>count)
				count=j-i+1;//count记录长度 
		}
		
		
	}
	
	cout<<count;	
	return 0;
}
/**************************************************************************************************************************/
/*
1034. 有理数四则运算(20)
本题要求编写程序，计算2个有理数的和、差、积、商。
输入格式： 
输入在一行中按照“a1/b1 a2/b2”的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为0。 
输出格式： 
分别在4行中按照“有理数1 运算符 有理数2 = 结果”的格式顺序输出2个有理数的和、差、积、商。
注意输出的每个有理数必须是该有理数的最简形式“k a/b”，其中k是整数部分，a/b是最简分数部分；若为负数，则须加括号；若除法分母为0，则输出“Inf”。
题目保证正确的输出中没有超过整型范围的整数。 
输入样例1：
2/3 -4/2
输出样例1：
2/3 + (-2) = (-1 1/3)
2/3 - (-2) = 2 2/3
2/3 * (-2) = (-1 1/3)
2/3 / (-2) = (-1/3)
输入样例2：
5/3 0/6
输出样例2：
1 2/3 + 0 = 1 2/3
1 2/3 - 0 = 1 2/3
1 2/3 * 0 = 0
1 2/3 / 0 = Inf
*/ 
#include <stdio.h>

typedef struct frac_{
long n, d, s;//分子n，分母d，符号s 
} FC;
// 求最大公约数的函数
long gcd(long a, long b)
{
return b == 0 ? a : gcd(b, a % b);
}
// 分数处理函数
FC hand(FC a)
{
    if (a.n < 0)// 如果分子为负，将符号赋给符号变量，分子取正值
	 {
		a.s *= -1;
		a.n *= -1;
	} 
    long tmp = gcd(a.n, a.d);//求最大公约数，即可约分的部分，化到最简形式 
    a.n /= tmp;// 分子和分母约分
    a.d /= tmp; 
    return a;
}

// 单个分数输出函数
void prt_fc(FC a)
{
    if (a.d == 0)
        printf("Inf"); // 如果分母为0，输出Inf
    else {
        long i = a.n / a.d; // 提取整数部分
        a.n = a.n % a.d; // 分数化为真分数
        a = hand(a); // 约分
        if (a.n == 0 && i == 0) printf("0"); // 如果整数小数部分均为0，输出0
        else {
            if (a.s == -1) printf("(-"); // 如果符号为负，则添加括号和负号
            if (i != 0) printf("%ld", i);//输出整数部分 
            if (i != 0 && a.n != 0) printf(" ");//若有整数部分，则输出整数之后的空格 
            if (a.n != 0) printf("%ld/%ld", a.n, a.d);//分子不为零，输出分数 
            if (a.s == -1) printf(")");
        }
    }
}
// 算式输出函数
void prt_eq(FC a, FC b, char c, FC (*fig)(FC, FC))
{
    prt_fc(a);
    printf(" %c ", c);
    prt_fc(b);
    printf(" = ");
    prt_fc(hand((*fig)(a, b)));
    printf("\n");
}

// 计算函数，加减乘除
FC plus (FC a, FC b){return (FC){a.s*a.n*b.d + b.s*b.n*a.d, a.d*b.d, 1};}

FC sub  (FC a, FC b) {return (FC){a.s*a.n*b.d - b.s*b.n*a.d, a.d*b.d, 1};}//（FC）为强制类型转换 

FC multi(FC a, FC b) {return (FC){a.n*b.n, a.d*b.d, a.s*b.s};}

FC divis(FC a, FC b) {return (FC){a.n*b.d, a.d*b.n, a.s*b.s};}

int main()
{
    FC a = {0, 0, 1}, b = {0, 0, 1}, (*fig[])(FC, FC) = {plus, sub, multi, divis};
    char c[5] = "+-*/";

    scanf("%ld/%ld %ld/%ld", &a.n, &a.d, &b.n, &b.d); // 读取分数a、b
    for (int i = 0; i < 4; i++)
        prt_eq(hand(a), hand(b), c[i], fig[i]); // 将处理过的分数，计算符号，计算函数、传递给算式输出函数

    return 0;
}
/**************************************************************************************************************************/
/*
1037. 在霍格沃茨找零钱（20）
如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，
二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱P和他实付的钱A，你的任务是写一个程序来计算他应该被找的零钱。 
输入格式： 
输入在1行中分别给出P和A，格式为“Galleon.Sickle.Knut”，其间用1个空格分隔。这里Galleon是[0, 107]区间内的整数，
Sickle是[0, 17)区间内的整数，Knut是[0, 29)区间内的整数。 
输出格式： 
在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。
输入样例1：
10.16.27 14.1.28
输出样例1：
3.2.1
输入样例2：
14.1.28 10.16.27
输出样例2：
-3.2.1
*/ 

#include<iostream>
using namespace std;
struct money{
	int galleon;
	int sickle;
	int knut;
};

int main()
{
	money x,y;
	long long int sumx,sumy;
	scanf("%d.%d.%d",&x.galleon,&x.sickle,&x.knut);
	scanf("%d.%d.%d",&y.galleon,&y.sickle,&y.knut);
	sumx=x.galleon*(17*29)+x.sickle*(29)+x.knut;
	sumy=y.galleon*(17*29)+y.sickle*(29)+y.knut;
	long long int count=sumy-sumx;
	if(sumy-sumx<0)
	{
		cout<<"-";
		count=-count;
	}
	cout<<count/(17*29)<<"."<<count%(17*29)/29<<"."<<count%29;
	
	
	
	
	return 0;
}
/**************************************************************************************************************************/
/*
1053. 住房空置率 (20)
在不打扰居民的前提下，统计住房空置率的一种方法是根据每户用电量的连续变化规律进行判断。判断方法如下： 
在观察期内，若存在超过一半的日子用电量低于某给定的阈值e，则该住房为“可能空置”； 
若观察期超过某给定阈值D天，且满足上一个条件，则该住房为“空置”。 
现给定某居民区的住户用电量数据，请你统计“可能空置”的比率和“空置”比率，即以上两种状态的住房占居民区住房总套数的百分比。 
输入格式： 
输入第一行给出正整数N（<=1000），为居民区住房总套数；正实数e，即低电量阈值；正整数D，即观察期阈值。
随后N行，每行按以下格式给出一套住房的用电量数据： 
K E1 E2 ... EK 
其中K为观察的天数，Ei为第i天的用电量。 
输出格式： 
在一行中输出“可能空置”的比率和“空置”比率的百分比值，其间以一个空格分隔，保留小数点后1位。 
输入样例：
5 0.5 10
6 0.3 0.4 0.5 0.2 0.8 0.6
10 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.5
5 0.4 0.3 0.5 0.1 0.7
11 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
11 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1
输出样例：
40.0% 20.0%
（样例解释：第2、3户为“可能空置”，第4户为“空置”，其他户不是空置。） 
*/ 
#include<iostream>
#include<cstdio>
using namespace std;
int main(){
    int N,D;
    double e;
    cin>>N>>e>>D;
    int n[N];
    double d;
    int possible=0;
    int must=0;
    for(int i=0;i<N;i++){
        int day=0;
        cin>>n[i];                  //输入观察的天数   
        for(int j=0;j<n[i];j++){    //输入每天观察的用电量
            cin>>d;
            if(d<e)                 //计算小于e的天数
                day++;
        }
        if(day>(n[i]/2)){           //如果超过一半的天数小于e则可能空置
            if(n[i]>D)              //如果观察天数超过D且满足上一条件则一定空置
                must++;
            else possible++;        //否则还是可能空置

        } 
    }                               //注意要先转换成double，不可以100*possible/N，如果possible=1，N=8，则为12.0,而不是12.5
    printf("%.1lf%% %.1lf%%\n", (double)possible / N * 100, (double)must / N * 100);  
    return 0;

}
/**************************************************************************************************************************/
/*
1054. 求平均值 (20)
本题的基本要求非常简单：给定N个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。
一个“合法”的输入是[-1000，1000]区间内的实数，并且最多精确到小数点后2位。当你计算平均值的时候，不能把那些非法的数据算在内。
输入格式： 
输入第一行给出正整数N（<=100）。随后一行给出N个实数，数字间以一个空格分隔。 
输出格式： 
对每个非法输入，在一行中输出“ERROR: X is not a legal number”，其中X是输入。
最后在一行中输出结果：“The average of K numbers is Y”，其中K是合法输入的个数，
Y是它们的平均值，精确到小数点后2位。如果平均值无法计算，则用“Undefined”替换Y。
如果K为1，则输出“The average of 1 number is Y”。 
输入样例1：
7
5 -3.2 aaa 9999 2.3.4 7.123 2.35
输出样例1：
ERROR: aaa is not a legal number
ERROR: 9999 is not a legal number
ERROR: 2.3.4 is not a legal number
ERROR: 7.123 is not a legal number
The average of 3 numbers is 1.38
输入样例2：
2
aaa -9999
输出样例2：
ERROR: aaa is not a legal number
ERROR: -9999 is not a legal number
The average of 0 numbers is Undefined
*/ 
#include<bits/stdc++.h>
using namespace std;
int main(){
    char *num[105];
    int N,count=0;
    double average=0;
    cin>>N;
    for(int i=0;i<N;i++){
        bool isNumber=true;     //判断是否为合法数字 
        int point=0;            //判断小数点之前的数字 
        int point_=0;           //判断小数点之后的数字
        num[i] = (char *)malloc(10*sizeof(char)); //申请内存空间
        cin>>num[i];
        int len=strlen(num[i]);
        double temp=atof(num[i]);//将每一个字符串转化为数字 
        if(temp<-1000||temp>1000)
		   isNumber=false;
        for(int j=0;j<len;j++){  //对每一个字符进行逐字的判断 
            if(point==1) point_++; //如果有小数点，则小数点之后位数++ 
            
            if(num[i][j]=='-'&&j!=0){//如果只有一个负号且在第一位 ，否则为非法 
                isNumber=false;
                break;
            }
            
            if(num[i][j]!='.'){ //如果不是小数点    
                if((num[i][j]<'0'||num[i][j]>'9')&&(num[i][j]!='-')){
                    isNumber=false;
                    break;
                }       
            }
			else {             //如果是小数点 
                point++;
            }
            if(point_>2||point>1){//如果有多个小数点或者小数点之后的数字有两位 
                isNumber=false;
                break;
            }
        }
        if(!isNumber)
            cout<<"ERROR: "<<num[i]<<" is not a legal number"<<endl;
        else {
            count++;
            average+=temp;
        }
    }
    if(count==1)
        printf("The average of 1 number is %.2lf",average);
    else if(count==0)
        printf("The average of 0 numbers is Undefined");
    else
        printf("The average of %d numbers is %.2lf",count,average/count);
    return 0;
}
/**************************************************************************************************************************/
/*
1056. 组合数的和(15)
给定N个非0的个位数字，用其中任意2个数字都可以组合成1个2位的数字。要求所有可能组合出来的2位数字的和。
例如给定2、5、8，则可以组合出：25、28、52、58、82、85，它们的和为330。
输入格式： 
输入在一行中先给出N（1<N<10），随后是N个不同的非0个位数字。数字间以空格分隔。 
输出格式： 
输出所有可能组合出来的2位数字的和。 
输入样例：
3 2 8 5
输出样例：
330
*/ 
#include<iostream>
using namespace std;
int main()
{
	int n,aa[11];
	cin>>n;
	int sum=0;
	for(int i=0;i<n;i++)
	{
		cin>>aa[i];
	 } 
	 for(int i=0;i<n;i++)
	 {
	 	for(int j=i+1;j<n;j++)
	 	{
	 		sum+=aa[i]*10+aa[j]+aa[j]*10+aa[i];
		 }
	 }
	 cout<<sum;
	return 0;
}
/**************************************************************************************************************************/
/*
1051. 复数乘法 (15)
复数可以写成(A + Bi)的常规形式，其中A是实部，B是虚部，i是虚数单位，满足i2 = -1；
也可以写成极坐标下的指数形式(R*e(Pi))，其中R是复数模，P是辐角，i是虚数单位，其等价于三角形式 R(cos(P) + isin(P))。
现给定两个复数的R和P，要求输出两数乘积的常规形式。
输入格式： 
输入在一行中依次给出两个复数的R1, P1, R2, P2，数字间以空格分隔。 
输出格式： 
在一行中按照“A+Bi”的格式输出两数乘积的常规形式，实部和虚部均保留2位小数。注意：如果B是负数，则应该写成“A-|B|i”的形式。 
输入样例：
2.3 3.5 5.2 0.4
输出样例：
-8.68-8.23i
*/
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int main(){
    double R1,P1,R2,P2;
    scanf("%lf%lf%lf%lf",&R1,&P1,&R2,&P2);
    double P=R1*R2*(cos(P1+P2));
    double R=R1*R2*(sin(P1+P2));
    if(P>-0.005&&P<0)
        printf("0.00");
    else 
        printf("%.2lf",P);
    if(R>-0.005&&R<0)
        printf("+0.00i");
    else if(R<=-0.005) 
        printf("%.2lfi",R);
    else printf("+%.2lfi",R);
    return 0;
}

/**************************************************************************************************************************/

/**************************************************************************************************************************/

/**************************************************************************************************************************/

/**************************************************************************************************************************/

/**************************************************************************************************************************/

/**************************************************************************************************************************/
