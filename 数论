/*
8.极差 (15分) 
题目内容：
在黑板上写了N个正整数组成的一个数列，进行如下操作：每次擦去其中的两个数a和b，
然后在数列中加入一个数a*b＋1，如此下去直至黑板上剩下一个数，在所有按这种操作方式
最后得到的数中，最大的为max，最小的为min，则该数列的极差定义为M＝max－min.请你编程，
对于给定的数列，计算极差.
输入描述
输入包含多个测试集.每个测试集的第一行N表示正整数序列长度（0＜＝N＜＝50000），随后第二行是N个正整数.当N为0时结束.
输出描述
每个结果一行.
输入样例
3
3 5 7
输出样例
4
*/
#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;
const int N=50000;//32位编译器最大值

bool cmp(const int i,const int j)
{
	return i>j;//定义降序排序 
 } 

int main()
{
	int n,i;
	int a[100],b[100];
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
		b[i]=a[i];
	}
	
	int tn=n;
	while(tn>1)
	{
		sort(a,a+n);
		a[1]=a[0]*a[1]+1;
		a[0]=N;
		tn--;
	}
	int max=a[1];
	tn=n;
	while(tn>1)
	{
		sort(b,b+n,cmp);
		b[1]=b[0]*b[1]+1;
		b[0]=0;
		tn--;
	}
	int min=b[1];
	cout<<abs(max-min);
	return 0;
 } 

/**************************************************************************************************************************/
/*
9. 带分数 (15分)
题目内容：
100 可以表示为带分数的形式：100 = 3 + 69258 / 714
还可以表示为：100 = 82 + 3546 / 197
注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。
类似这样的带分数，100 有 11 种表示法。
题目要求：
从标准输入读入一个正整数N (N<1000*1000)
程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。
注意：不要求输出每个表示，只统计有多少表示法！
输入描述
从标准输入读入一个正整数N (N<1000*1000)
输出描述
程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。
输入样例
100
输出样例
11
*/ 
#include<iostream>
#include<algorithm>
using namespace std;
int p[9];
int cnt[1000005];
int main()
{
	for(int i=0;i<9;i++)
		p[i]=i+1;
	int a,b,c,ans;
	do{

		for(int i=0;i<=6;i++)
			for(int j=i+1;j<=7;j++)
			{
				a=0;
				b=0;
				c=0;
				ans=0;
				for(int k=0;k<=i;k++)
					a=a*10+p[k];
				for(int k=i+1;k<=j;k++)
					b=b*10+p[k];
				for(int k=j+1;k<=8;k++)
					c=c*10+p[k];
				if(b%c==0)
					{
					ans=a+b/c;
					if(ans<1000000)
					cnt[ans]++;
					}

			}

	}
	while(next_permutation(p,p+9));
		int n;
		cin>>n;
		cout<<cnt[n];

}


/*
思路：
首先，这个题用暴力枚举一定会超时的，所以我就没试。
为何暴力枚举会超时？
原因在于，暴力枚举会搜索到很庞大的没有用的数据，最后在十几万甚至几百万个组合中，也许仅仅只有十几种
组合符合条件，这就大大的浪费了时间。想要避免这类事件的发生，就要有好的剪枝条件。
如何建造好的剪枝条件？
本题说的是，n=a+b/c；那么首先a一定是小于n的，又因为n为整数，所以a和b/c都是整数，这就要求
b/c一定可以整除，所以b%c=0，b/c还要满足可除条件，即b>=c。剪枝的三个条件已经确定
(1).a<n；
(2).b%c=0；
(3).b>=c
再加上n=a+b/c就是四个条件了。只要在1至9的全排列中选取满足这四个条件的全排列就是所求的结果之一。
那么在1至9的全排列（9个数字）中如何确定a，b，c的取值范围呢？
a前面已经说过，而又知道，b一定大于或等于c，则b的取值范围一定在a选择过后去选择剩下的一半或一半以上的数据。举个例子，1至9的其中一个全排列--156987423，若a选择156，则b只能选择剩下的987423中的一半或
一半以上，如987、9874、98742。如果b小于剩下的一半，那么一定不满足除法（如98/7432）。c
的范围则是a和b选择剩下的所有了。这样我们就可以判定，假设num=9，a选择9位中的前n位，那
么b的结尾选择范围为第n+（num-n）/2至num-1位数字（结尾为一半或一半以上，最多时到num-1
，给c留一个数字）；
那么利用深度优先搜索（用来得到一个9位的全排列）和适当的判断（剪枝，找出符合3个条件并
且满足n=a+b/c的全排列）就可以解决。
AC代码：

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<time.h>
int aws=0;
int a[10],flag[10];
int sum(int start,int end)
{
	int i,sum=0; 
	for(i=start;i<end;i++)
	sum=sum*10+a[i+1]; 
	return sum;
}
void Found(int a[],int n,int m)//将DFS中的每一个全排列结果放在Found函数中检验
{
	int i,j,begin=0;
	for(i=1;i<n;i++)
	{
		int m1=sum(0,i);//第一个数从1至9开始选?
		if(m1>=m) return;//不满足第一个数<m的直接淘汰?
		for(j=i+(n-i)/2;j<n-1;j++)
		{
			int m2=sum(i,j);//第二个数?
			int m3=sum(j,n-1);//第三个数?
			if(m2>m3&&m2%m3==0&&m==m1+m2/m3)
			{
				aws++;
			}
		}
	}
}
void DFS(int start,int n,int m)//对1~9进行全排列?
{
	int i;
	if(start==n)
	Found(a,n,m);
	else
	{
		for(i=1;i<n;i++)
		{
			if(flag[i])
			 continue; 
			a[start]=i; 
			flag[i]=1; 
			DFS(start+1,n,m);//选择好一位开始选下一位
			flag[i]=0;
		}
	}
}
int main()
{
	int i,j,m;
	double s1,s2;
	memset(flag,0,sizeof(flag));
	scanf("%d",&m);
	DFS(1,10,m);
	printf("%d\n",aws);
	return 0;
}
检测100所用的时间： 


100
100=3+69258/714
100=81+5643/297
100=81+7524/396
100=82+3546/197
100=91+5742/638
100=91+5823/647
100=91+7524/836
100=94+1578/263
100=96+1428/357
100=96+1752/438
100=96+2148/537
11
420ms
*/

/**************************************************************************************************************************/
/*
9.完美数 (15分) 
题目内容：
如果有一正整数n，其真因数的总和等于n，则称之为完美数。
例如以下几个数都是完美数：
6=1+2+3
28=1+2+4+7+14
496=1+2+4+8+16+31+62+124+248
求小于n的所有完美数.
输入描述
输入一个正整数n
输出描述
输出小于n的完美数，按升序输出，每个数据占一行
输入样例
10
输出样例
6
*/
#include<stdio.h>
int main()
{
	int n,N;
	int i,j,k,sum;
	scanf("%d",&N);
	for(n=2;n<=N;n++)
	{
		sum=0;
		for(i=1;i<n;i++)
		{
			if(n%i==0)
				sum=sum+i;
		}	
		if(sum==n)
			printf("%d\n",n);	
	}
	
	return 0;
}
/**************************************************************************************************************************/
/*
最大k乘积问题
http://blog.csdn.net/qq_27601815/article/details/52938608
题目内容：
设I是一个n位十进制整数.如果将I划分为k段,则可得到k个整数.这k个整数的乘积称为I的一个k乘积.
试设计一个算法,对于给定的I和k ,求出I的最大k乘积.
Input
输入的第1行中有2个正整数n和k.正整数n是序列的长度;正整数k是分割的段数.接下来的一行中是一个
n位十进制整数.（n<=10）
Output
输出计算结果，第1行中的数是计算出的最大k乘积.
n位十进制整数.（n<=10）
输入样例
2 1
15
输出样例
15
*/
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
const int M=11;
int nik[M][M];
int dp[M][M];

int main()
{
	int ws,k;
	int n;
		scanf("%d%d",&ws,&k);//ws为位数 
		scanf("%d",&n);
		memset(dp,0,sizeof(dp)); 
		if(k==1)
		{
			printf("%d\n",n);
		}
		else
		{
			for(int i=1;i<=ws;i++)
			{
				int p=10;
				for(int j=i;j<=ws;j++)
				{
					nik[i][j]=n%p;//将n位十进制数按照不同段存储于nik二维数组中 ，例如将45678分别存储为8 78 678 5678 45678 
					p*=10;
				}
				n/=10;//将每一排 遍历所有的存储，第一排由1位8开始，第二排由二位78开始 ，以此类推至最后 
			}
			
		for(int i=1;i<=ws;i++)
		{
			dp[i][1]=nik[1][i];// 将nik第一排的数字存储至竖列 
		}
		for(int i=2;i<=k;i++)//填表式相乘 
		{
			for(int j=1;j<=ws;j++)
			{
				int maxn=0;
				for(int k=1;k<j;k++)
				{
				maxn=max(dp[k][i-1]*nik[k+1][j],maxn);//dp[j][i]中存储这种分割组合中的相乘结果，并按顺序排序 
				}
	
			dp[j][i]=maxn;
			}
		}
		printf("%d\n",dp[ws][k]);//最后dp[ws][k]即最后一格填表为最大值 
		}
	return 0;
}


/**************************************************************************************************************************/
