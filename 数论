/*
8.极差 (15分) 
题目内容：
在黑板上写了N个正整数组成的一个数列，进行如下操作：每次擦去其中的两个数a和b，
然后在数列中加入一个数a*b＋1，如此下去直至黑板上剩下一个数，在所有按这种操作方式
最后得到的数中，最大的为max，最小的为min，则该数列的极差定义为M＝max－min.请你编程，
对于给定的数列，计算极差.
输入描述
输入包含多个测试集.每个测试集的第一行N表示正整数序列长度（0＜＝N＜＝50000），随后第二行是N个正整数.当N为0时结束.
输出描述
每个结果一行.
输入样例
3
3 5 7
输出样例
4
*/
#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;
const int N=50000;//32位编译器最大值

bool cmp(const int i,const int j)
{
	return i>j;//定义降序排序 
 } 

int main()
{
	int n,i;
	int a[100],b[100];
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
		b[i]=a[i];
	}
	
	int tn=n;
	while(tn>1)
	{
		sort(a,a+n);
		a[1]=a[0]*a[1]+1;
		a[0]=N;
		tn--;
	}
	int max=a[1];
	tn=n;
	while(tn>1)
	{
		sort(b,b+n,cmp);
		b[1]=b[0]*b[1]+1;
		b[0]=0;
		tn--;
	}
	int min=b[1];
	cout<<abs(max-min);
	return 0;
 } 

/**************************************************************************************************************************/
/*
9. 带分数 (15分)
题目内容：
100 可以表示为带分数的形式：100 = 3 + 69258 / 714
还可以表示为：100 = 82 + 3546 / 197
注意特征：带分数中，数字1~9分别出现且只出现一次（不包含0）。
类似这样的带分数，100 有 11 种表示法。
题目要求：
从标准输入读入一个正整数N (N<1000*1000)
程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。
注意：不要求输出每个表示，只统计有多少表示法！
输入描述
从标准输入读入一个正整数N (N<1000*1000)
输出描述
程序输出该数字用数码1~9不重复不遗漏地组成带分数表示的全部种数。
输入样例
100
输出样例
11
*/ 
#include<iostream>
#include<algorithm>
using namespace std;
int p[9];
int cnt[1000005];
int main()
{
	for(int i=0;i<9;i++)
		p[i]=i+1;
	int a,b,c,ans;
	do{

		for(int i=0;i<=6;i++)
			for(int j=i+1;j<=7;j++)
			{
				a=0;
				b=0;
				c=0;
				ans=0;
				for(int k=0;k<=i;k++)
					a=a*10+p[k];
				for(int k=i+1;k<=j;k++)
					b=b*10+p[k];
				for(int k=j+1;k<=8;k++)
					c=c*10+p[k];
				if(b%c==0)
					{
					ans=a+b/c;
					if(ans<1000000)
					cnt[ans]++;
					}

			}

	}
	while(next_permutation(p,p+9));
		int n;
		cin>>n;
		cout<<cnt[n];

}


/*
思路：
首先，这个题用暴力枚举一定会超时的，所以我就没试。
为何暴力枚举会超时？
原因在于，暴力枚举会搜索到很庞大的没有用的数据，最后在十几万甚至几百万个组合中，也许仅仅只有十几种
组合符合条件，这就大大的浪费了时间。想要避免这类事件的发生，就要有好的剪枝条件。
如何建造好的剪枝条件？
本题说的是，n=a+b/c；那么首先a一定是小于n的，又因为n为整数，所以a和b/c都是整数，这就要求
b/c一定可以整除，所以b%c=0，b/c还要满足可除条件，即b>=c。剪枝的三个条件已经确定
(1).a<n；
(2).b%c=0；
(3).b>=c
再加上n=a+b/c就是四个条件了。只要在1至9的全排列中选取满足这四个条件的全排列就是所求的结果之一。
那么在1至9的全排列（9个数字）中如何确定a，b，c的取值范围呢？
a前面已经说过，而又知道，b一定大于或等于c，则b的取值范围一定在a选择过后去选择剩下的一半或一半以上的数据。举个例子，1至9的其中一个全排列--156987423，若a选择156，则b只能选择剩下的987423中的一半或
一半以上，如987、9874、98742。如果b小于剩下的一半，那么一定不满足除法（如98/7432）。c
的范围则是a和b选择剩下的所有了。这样我们就可以判定，假设num=9，a选择9位中的前n位，那
么b的结尾选择范围为第n+（num-n）/2至num-1位数字（结尾为一半或一半以上，最多时到num-1
，给c留一个数字）；
那么利用深度优先搜索（用来得到一个9位的全排列）和适当的判断（剪枝，找出符合3个条件并
且满足n=a+b/c的全排列）就可以解决。
AC代码：

#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<time.h>
int aws=0;
int a[10],flag[10];
int sum(int start,int end)
{
	int i,sum=0; 
	for(i=start;i<end;i++)
	sum=sum*10+a[i+1]; 
	return sum;
}
void Found(int a[],int n,int m)//将DFS中的每一个全排列结果放在Found函数中检验
{
	int i,j,begin=0;
	for(i=1;i<n;i++)
	{
		int m1=sum(0,i);//第一个数从1至9开始选?
		if(m1>=m) return;//不满足第一个数<m的直接淘汰?
		for(j=i+(n-i)/2;j<n-1;j++)
		{
			int m2=sum(i,j);//第二个数?
			int m3=sum(j,n-1);//第三个数?
			if(m2>m3&&m2%m3==0&&m==m1+m2/m3)
			{
				aws++;
			}
		}
	}
}
void DFS(int start,int n,int m)//对1~9进行全排列?
{
	int i;
	if(start==n)
	Found(a,n,m);
	else
	{
		for(i=1;i<n;i++)
		{
			if(flag[i])
			 continue; 
			a[start]=i; 
			flag[i]=1; 
			DFS(start+1,n,m);//选择好一位开始选下一位
			flag[i]=0;
		}
	}
}
int main()
{
	int i,j,m;
	double s1,s2;
	memset(flag,0,sizeof(flag));
	scanf("%d",&m);
	DFS(1,10,m);
	printf("%d\n",aws);
	return 0;
}
检测100所用的时间： 


100
100=3+69258/714
100=81+5643/297
100=81+7524/396
100=82+3546/197
100=91+5742/638
100=91+5823/647
100=91+7524/836
100=94+1578/263
100=96+1428/357
100=96+1752/438
100=96+2148/537
11
420ms
*/

/**************************************************************************************************************************/
/*
9.完美数 (15分) 
题目内容：
如果有一正整数n，其真因数的总和等于n，则称之为完美数。
例如以下几个数都是完美数：
6=1+2+3
28=1+2+4+7+14
496=1+2+4+8+16+31+62+124+248
求小于n的所有完美数.
输入描述
输入一个正整数n
输出描述
输出小于n的完美数，按升序输出，每个数据占一行
输入样例
10
输出样例
6
*/
#include<stdio.h>
int main()
{
	int n,N;
	int i,j,k,sum;
	scanf("%d",&N);
	for(n=2;n<=N;n++)
	{
		sum=0;
		for(i=1;i<n;i++)
		{
			if(n%i==0)
				sum=sum+i;
		}	
		if(sum==n)
			printf("%d\n",n);	
	}
	
	return 0;
}
/**************************************************************************************************************************/
/*
最大k乘积问题
http://blog.csdn.net/qq_27601815/article/details/52938608
题目内容：
设I是一个n位十进制整数.如果将I划分为k段,则可得到k个整数.这k个整数的乘积称为I的一个k乘积.
试设计一个算法,对于给定的I和k ,求出I的最大k乘积.
Input
输入的第1行中有2个正整数n和k.正整数n是序列的长度;正整数k是分割的段数.接下来的一行中是一个
n位十进制整数.（n<=10）
Output
输出计算结果，第1行中的数是计算出的最大k乘积.
n位十进制整数.（n<=10）
输入样例
2 1
15
输出样例
15
*/
#include <iostream>
#include <stdio.h>
#include <string.h>
using namespace std;
const int M=11;
int nik[M][M];
int dp[M][M];

int main()
{
	int ws,k;
	int n;
		scanf("%d%d",&ws,&k);//ws为位数 
		scanf("%d",&n);
		memset(dp,0,sizeof(dp)); 
		if(k==1)
		{
			printf("%d\n",n);
		}
		else
		{
			for(int i=1;i<=ws;i++)
			{
				int p=10;
				for(int j=i;j<=ws;j++)
				{
					nik[i][j]=n%p;//将n位十进制数按照不同段存储于nik二维数组中 ，例如将45678分别存储为8 78 678 5678 45678 
					p*=10;
				}
				n/=10;//将每一排 遍历所有的存储，第一排由1位8开始，第二排由二位78开始 ，以此类推至最后 
			}
			
		for(int i=1;i<=ws;i++)
		{
			dp[i][1]=nik[1][i];// 将nik第一排的数字存储至竖列 
		}
		for(int i=2;i<=k;i++)//填表式相乘 
		{
			for(int j=1;j<=ws;j++)
			{
				int maxn=0;
				for(int k=1;k<j;k++)
				{
				maxn=max(dp[k][i-1]*nik[k+1][j],maxn);//dp[j][i]中存储这种分割组合中的相乘结果，并按顺序排序 
				}
	
			dp[j][i]=maxn;
			}
		}
		printf("%d\n",dp[ws][k]);//最后dp[ws][k]即最后一格填表为最大值 
		}
	return 0;
}

/**************************************************************************************************************************/
/*
5.2-6 数列求和 (20分) 
题目内容：
给定某数字A（1<=A<=9）以及非负整数N（0<=N<=100000），
求数列之和S = A + AA + AAA + … + AA…A(N个A)。例如A=1, N=3时，
S = 1 + 11 + 111 = 123。
输入描述
输入数字A与非负整数N。
输出描述
输出其N项数列之和S的值。
输入样例
序号	输入	
1	1 3	
2	6 100	
3	1 0	
输出样例
序号 输出
1    123
2  7407407407407407407407407407407407407407407407407407407407407407407407407407407407407407407407407340
3     0
*/ 

#include<stdio.h>
int main()
{
	int q,n,i,j,k,lenb,m;
	char a[10000]={0},b[10000]={0},c[10000]={0};
	scanf("%d%d",&q,&n);
	
	if(n==0)
	{
	printf("%d",n);		
	}
	else
	{
		for(i=1;i<=n;i++)
		{
			for(j=0;j<=i;j++)//输入每一个数字,每一个数字都是i个长度 
			{
				a[j]=q;
			//	printf("ok\n");
			}
			for(j=0;j<i;j++)
			{
				b[j]+=a[j];
				if(b[j]>9)
				{
					b[j]=b[j]%10;
					b[j+1]++;
				}
			}
			b[i]='\0';
		}
		
		for(i=10000;(i>=0)&&(b[i]==0);i--);//从最高位找出不是零的数字输出 
		if(i>=0)
		{
			for(;i>=0;i--)
			printf("%d",b[i]);
		}	
	}

	return 0;	
}
/**************************************************************************************************************************/
/*
7.寻找最大数 
题目内容：
请在整数 n 中删除m个数字, 使得余下的数字按原次序组成的新数最大，
比如当n=92081346718538，m=10时，则新的最大数是9888
输入描述 
第一行输入一个正整数T，表示有T组测试数据每组测试数据占一行，每行有两个数n,m
（n可能是一个很大的整数，但其位数不超过100位，并且保证数据首位非0，m小于整数n的位数）
输出描述
每组测试数据的输出占一行，输出剩余的数字按原次序组成的最大新数
输入样例
2
92081346718538 10
1008908 5
输出样例
9888
98
*/
#include<stdio.h>
#include<string.h> 
int main()
{
	int n,m;
	int i,j,k,len,max,p,q,num;
	char s[100],a[100];
	scanf("%d",&n);
	while(n--)
	{	
		memset(s,'\0',sizeof(s));//动态内存分配 
		scanf("%s %d",s,&m);
		len=strlen(s);
		num=len-m;
		j=0;
		max=0;
		memset(a,'\0',sizeof(a));
		while(num--)
		{
			for(i=max+1;i<len-num;i++)//从左往右找最大的数，这一次找时从上次找到的最大数的下一位开始找
			{
				if(s[i]>s[max])
				max=i;
			}
		a[j++]=s[max];
		max=max+1;	
		}
		
		for(i=0;i<j;i++)
		printf("%c",a[i]);	
		printf("\n");
	}
	
	return 0;
 } 
/**************************************************************************************************************************/
/*
题目内容：
YF不爱名利，所以他既不喜欢6，也不喜欢8。他的幸运数字是4和7。如果一个数字中只包含4和7，他就认为这个数字是他的幸运数。
现在给你两个正整数a,b，要求返回a,b之间的幸运数的个数，包括a,b本身。
输入描述
第一行输入数目n,表示后面有n组ab
第2行开始，每行一组a b, 空格隔开。
输出描述
每行输出一个数，即a,b之间的幸运数的个数。
输入样例
3
11 20
4 7
1 10
输出样例
0
2
2
*/
#include <stdio.h>
int b[10000];
int fun(int a)//判断是否为幸运数字 
{
	int m,n,i,j,t=0,b[10000];
	for(n=a,i=0;n!=0;i++)
	{
		m=n%10;
		n=n/10;
		b[i]=m;
	}
	for(j=0;j<i;j++)
	{
		if(b[j]!=4&&b[j]!=7)
		{
			t=0;
			break;
		}
		else
		t=1;
	}
	return t; 
}
int main()
{
    int n,a,b,sum[10000];
	int i,j;
	scanf("%d",&n);//输入数目n 
	for(i=0;i<n;i++)
	{
		scanf("%d%d",&a,&b);//输入区间a,b 
		sum[i]=0;//记录每个区间的个数 
		for(j=a;j<=b;j++)
		{
			sum[i]+=fun(j);
		}
	}
	for(i=0;i<n;i++)
		printf("%d\n",sum[i]);
	return 0;
}
/**************************************************************************************************************************/
/*
17.约瑟夫环 (5分) 
题目内容：
有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的
人退出圈子，问最后留下的是原来第几号的那位?
输入描述
正整数n
输出描述
直接输出结果
输入样例
10
输出样例
4
*/

#include<stdio.h>
int main()
{
	int n,i,k,j,str[100]={0},*p;
	scanf("%d",&n);
	p=str;
	for(i=0;i<n;i++)
	p[i]=i+1;

	i=0;
	j=1;
	k=0;
	int all=n;
	while(n>0)
	{
		if(i>=all)
		i=i%all;
		
		if(p[i]!=0)
		{
			if(j==3)//如果遇到3就退出 
			{
				k=i+1;
			//	printf("%d\n",i+1);
				p[i]=0; 
				j=1;//j从1开始重新计数
				i++;
				n--;//总人数减一 
			
			}
			else//如果j不是3就继续 
			{
				i++;
				j++;
			}
		}
		else
		i++;
	}
	printf("%d",k);
	return 0;
}
/**************************************************************************************************************************/
/*题目内容：
对于一个正整数n的划分，就是把n变成一系列正整数之和的表达式。注意，分划与顺序无关，例如6=5+1跟6=1+5是
同一种分划。另外，单独这个整数本身也算一种分划。
例如：对于正整数n=5，可以划分为：
1+1+1+1+1
1+1+1+2
1+1+3
1+2+2
2+3
1+4
5
输入描述
输入一个正整数n
输出描述
输出n整数划分的总数k
输入样例
5
输出样例
7
*/

#include<stdio.h>
#include<iostream>
using namespace std;

int equationCount(int n,int m)
{
    if(n==1||m==1)
        return 1;
    else if(n<m)
        return equationCount(n,n);
    else if(n==m)
        return 1+equationCount(n,n-1);
    else
        return equationCount(n,m-1)+equationCount(n-m,m);
}

int main(void)
{
    int n;
    if(scanf("%d",&n)!=EOF&&(n>=1&&n<=120))
    
        printf("%d\n",equationCount(n,n));
    
    return 0;
}

/*
f(n, m)= 1; (n=1 or m=1) 
f(n, m)=f(n, n); (n<m) 
1+ f(n, m-1); (n=m) 
f(n-m,m)+f(n,m-1); (n>m) 
*/
/**************************************************************************************************************************/
/**************************************************************************************************************************/
/**************************************************************************************************************************/
/**************************************************************************************************************************/


