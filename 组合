/*
2.二十四点 (15分) 
C时间限制：1?毫秒?|? C内存限制：3000?Kb
题目内容：
问题描述：输入4个数，通过 加、减、乘、除运算看能否得到 结果 24，每个数只用一次。
输入描述
输入四个正整数
输出描述
能通过某种方式得到24则输出1，不能则输出0
输入样例
6 6 6 6
输出样例
1
*/

#include<stdio.h>
#include<stdlib.h>
char mark[4]={'+','-','*','/'};

float cal(float x,float y,int mark)//定义计算函数 
{
  switch(mark)
  {
    case 0:return x+y;
    case 1:return x-y;
    case 2:return x*y;
    case 3:return x/y;
  }
}

/*calculateA~calculateE分别计算所有括号情况，函数算法为括号优先级*/ 
float calculate_A(float a,float b,float c,float d,int mark1,int mark2,int mark3)
{
  float r1,r2,r3;
  r1=cal(a,b,mark1);
  r2=cal(r1,c,mark2);
  r3=cal(r2,d,mark3);
  return r3;
}
float calculate_B(float a,float b,float c,float d,int mark1,int mark2,int mark3)
{
  float r1,r2,r3;
  r1=cal(b,c,mark2);
  r2=cal(a,r1,mark1);
  r3=cal(r2,d,mark3);
  return r3;
}
float calculate_C(float a,float b,float c,float d,int mark1,int mark2,int mark3)
{
  float r1,r2,r3;
  r1=cal(c,d,mark3);
  r2=cal(b,r1,mark2);
  r3=cal(a,r2,mark1);
  return r3;
}
float calculate_D(float a,float b,float c,float d,int mark1,int mark2,int mark3)
{
  float r1,r2,r3;
  r1=cal(b,c,mark2);
  r2=cal(r1,d,mark3);
  r3=cal(a,r2,mark1);
  return r3;
}
float calculate_E(float a,float b,float c,float d,int mark1,int mark2,int mark3)
{
  float r1,r2,r3;
  r1=cal(a,b,mark1);
  r2=cal(c,d,mark3);
  r3=cal(r1,r2,mark2);
  return r3;
}

/*get函数为计算函数，若有解法，flag为1，若没有解法，flag为0*/ 
float get(int a,int b,int c,int d)
{
  int mark1,mark2,mark3;
  float flag=0;
  for(mark1=0;mark1<4;mark1++)//四个数字只能同时存在三种运算符，遍历所有运算符的情况 
  {
    for(mark2=0;mark2<4;mark2++)
    {
      for(mark3=0;mark3<4;mark3++)
      {
        if(calculate_A(a,b,c,d,mark1,mark2,mark3)==24)
        {
          //printf("((%d%c%d)%c%d)%c%d=24\n",a,mark[mark1],b,mark[mark2],c,mark[mark3],d);
          flag=1;
        }
        else if(calculate_B(a,b,c,d,mark1,mark2,mark3)==24)
        {
          //printf("(%d%c(%d%c%d))%c%d=24\n",a,mark[mark1],b,mark[mark2],c,mark[mark3],d);
          flag=1;
        }
        else if(calculate_C(a,b,c,d,mark1,mark2,mark3)==24)
        {
          //printf("%d%c(%d%c(%d%c%d))=24\n",a,mark[mark1],b,mark[mark2],c,mark[mark3],d);
          flag=1;
        }
        else if(calculate_D(a,b,c,d,mark1,mark2,mark3)==24)
        {
          //printf("%d%c((%d%c%d)%c%d)=24\n",a,mark[mark1],b,mark[mark2],c,mark[mark3],d);
          flag=1;
        }
        else if(calculate_E(a,b,c,d,mark1,mark2,mark3)==24)
        {
          //printf("(%d%c%d)%c(%d%c%d)=24\n",a,mark[mark1],b,mark[mark2],c,mark[mark3],d);
          flag=1;
        }
      }
    }

  }
  printf("%.0f\n",flag);
  return flag;
}


int main()
{
  int a,b,c,d;
//  printf("Please input 4 numbers(1~13):");
  scanf("%d%d%d%d",&a,&b,&c,&d);
    if((a>=1&&a<=13)&&(b>=1&&b<=13)&&(c>=1&&c<=13)&&(d>=1&&d<=13))
    {
      get(a,b,c,d);
    }
/*      else
      {
        printf("Input illegal,please input again(1~13):");
        scanf("%d%d%d%d",&a,&b,&c,&d);
        if((a>=1&&a<=13)&&(b>=1&&b<=13)&&(c>=1&&c<=13)&&(d>=1&&d<=13))
         {
              get(a,b,c,d);
         }
      }*/
      //printf("%d\n",y);
 // system("pause");
 return 0;
 
}
/*************************************************************************************************/
/*
2.钱组合数 (15分) 
C时间限制：3?毫秒?|? C内存限制：3000?Kb
题目内容：
给你足够多的1，2，5面值的钱币，输入一个钱数n，设计一个程序使能够计算出所有的组合！
输入描述
钱数N
输出描述
所有的组合数的个数
输入样例
20
输出样例
29
*/

#include<stdio.h>
int main()
{
	int money,a,b,c,i;
	scanf("%d",&money);
	i=0;
	for(a=0;a<=money;a++)
	for(b=0;b<=money/2;b++)
	for(c=0;c<=money/5;c++)
	{
	if(1*a+2*b+c*5==money)
	i=i+1;
	}
	printf("%d",i);
	return 0;
 } 

/*************************************************************************************************/
/*
砝码组合
题目内容：
用天平称重时，我们希望用尽可能少的砝码组合称出尽可能多的重量。
如果只有5个砝码，重量分别是1，3，9，27，81。
则它们可以组合称出1到121之间任意整数重量（砝码允许放在左右两个盘中）。
本题目要求编程实现：对用户输入的重量(1~121)，
给出砝码组合方案（用加减式表示，减代表砝码放在物品盘）。
例如：
输入：
5
输出：
9-3-1
输入：
19
输出：
27-9+1
要求程序输出的组合总是大数在前小数在后。
输入描述
用户输入的重量(1~121)，
输出描述
给出砝码组合方案（用加减式表示，减代表砝码放在物品盘）。
输入样例
19
输出样例
27-9+1
*/ 

/*
编程思路：把数字用三进制表示出来，然后把三进制中的2换成-1，
同时向前进一位，先转换输出最后一位数字 ，之后的数字如果是1则表示+，
如果是-1则表示-，如果是0 则不做变换 
*/
#include<stdio.h>

int fun(int p)
{
	int i=1,j;
	for(j=0;j<p;j++)
	{
		i=3*i;
	}
	return i;
}

int main()
{
	int n,i,j,k;
	int a[6]={0};
	
	scanf("%d",&n);
	
	for(i=0;i<6;i++)//进行三进制转换并将2换为-1同时向前进一位 
	{
		a[i]=n%3+a[i];
		if(a[i]==3)
		{
			a[i]=0;
			a[i+1]=1;
		}
		else if(a[i]==2)
		{
			a[i]=-1;
			a[i+1]=1;
		}
		n=n/3;
		if(n==0)
		{
			break;
		}	
	}
	
	if(a[i+1]==1) 
	printf("%d",fun(i+1));
	
	for(j=i;j>-1;j--)
	{
		if(a[j]==1)
		{
			printf("+%d",fun(j));
		}
		if(a[j]==-1)
		{
			printf("-%d",fun(j));
		}
	}
	return 0;
}
/*************************************************************************************************/
/*
题目内容：
把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？
M, N为自然数。说明：如有7个苹果，3个盘子，
则(5, 1, 1)和(1, 5, 1)和(1, 1, 5)都是同一种分法。
输入描述
第一行一个整数表示数据的组数（多组数据），对于每组数据第一行是苹果个数M (1 ≤ m ≤ 100) ，
第二行是盘子个数N(1 ≤ n ≤ 100)。
输出描述
每组数据输出一行,放苹果的方法个数。
输入样例
1 
3 
2
输出样例
2
*/
#include<stdio.h>

int fun(int m,int n)
{
	if(m==0||n==1)//如果没有苹果或者只有一个盘子，则只有一种情况 
	return 1;
	if(n>m)//当n>m时，必定有n-m个盘子空着，即为m个苹果放到m个盘子的情况 
	return fun(m,m); 
	else 
	return fun(m,n-1)+fun(m-n,n);
	/*
	当n <= m:不同的放法可以分成两类：含有0的方案数，不含有0的方案数
含有0的方案数，即有至少一个盘子空着，即相当于 f(m,n)=f(m,n-1);
不含有0的方案数，即所有的盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，
不影响不同放法的数目，即 f(m,n)=f(m-n,n).
而总的放苹果的放法数目等于两者的和，即 f(m,n)=f(m,n-1)+f(m-n,n)
	*/ 
 } 

int main()
{
	int m,n,c,i,j,k;
	scanf("%d",&c);//c为测试数据组数 
	for(i=0;i<c;i++)
	{
		scanf("%d",&m);//有m个苹果放入n个盘子 
		scanf("%d",&n);
		printf("%d",fun(m,n));
	}
}
/*************************************************************************************************/
/*
8.甲乙混战 (15分) 
C时间限制：3000?毫秒?|? C内存限制：3000?Kb
题目内容：
 某游戏规则中，甲乙双方每个回合的战斗总是有一方胜利，一方失败。
游戏规定：失败的一方要把自己的体力值的1/4加给胜利的一方。例如：
如果双方体力值当前都是4，则经过一轮战斗后，双方的体力值会变为：5，3。
现在已知：双方开始时的体力值甲：1000，乙：2000。
假设战斗中，甲乙获胜的概率都是50%求解：双方经过4个回合的战斗，
体力值之差小于1000的理论概率。
输入描述
此题直接编译出结果就可，不需要输入数据
输出描述
输出4个回合的战斗后体力值之差小于1000的理论概率，保留6位小数
输入样例
此题直接编译出结果就可，不需要输入数据
输出样例
0.625000
*/ 
#include<stdio.h>
#include<stdlib.h> 
int abs(int x)
{
	if(x>=0)
	return x;
	else
	return -x;
}


int main()
{
	int x=1000,y=2000;
	int i,j,k,t,s,count=0;
	for(i=0;i<16;i++)//总共16种胜负结果的情况
	{
		x=1000;
		y=2000;
		for(k=0;k<4;k++)//取0-15的从左到右数的1~4位 
		{
			t=i>>k&1;//i的二进制中，从右往左数，取第k+1位上的值 
	
			if(t==1)//甲获得胜利
			{
				x+=y/4;
				y-=y/4; 
			} 
			else
			{
				y+=x/4;
				x-=x/4;
			}
		}
		if(abs(x-y)<1000)
		count++;
	 } 
	printf("%.6lf\n",(double)(count)/16);
	
	return 0;
}

















