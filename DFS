/*
题目内容：
 Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，
 滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。
 Michael想知道载一个区域中最长底滑坡。区域由一个二维数组给出。
 数组的每个数字代表点的高度。下面是一个例子 
 1  2  3  4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。
在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。
事实上，这是最长的一条。
输入描述
输入的第一行表示区域的行数R和列数C(1<=R,C<=100)。下
面是R行，每行有C个整数，代表高度h，0<=h<=10000。
输出描述
输出最长区域的长度。
输入样例
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
输出样例
25
*/

#include<stdio.h>
#include<iostream>
#include<string.h>
int map[105][105];
int step[105][105];//存储了当前滑最长的距离
int dir[4][2]={{-1,0},{1,0},{0,1},{0,-1}};//定义四个方向
int n,m;

int dfs(int x,int y)
{
	int k,xx,yy,tmp;
	if(step[x][y])
	return step[x][y];//如果这个状态存储了，就可以直接返回 
	
	tmp=0;
	
	for(k=0;k<4;k++)//把四个方向都走一遍然后存储 
	{
		xx=x+dir[k][0];
		yy=y+dir[k][1];
		 if(map[xx][yy]<map[x][y]&&xx>=0&&xx<n&&yy>=0&&yy<n)
		 {
		 	tmp=dfs(xx,yy);//从周围四个方向滑的区域距离值
			step[x][y]=tmp>=step[x][y]?(tmp+1):(step[x][y]);
			//找出最大值tmp，也就是当前的最优决策，把这个点(x,y)的step[x][y]赋值成tmp+1 
		 }	
	}
	return step[x][y]; 
}

int main()
{
	int i,j;
	int maxx=0,temp;
	
	scanf("%d%d",&n,&m);
	for(i=0;i<n;i++)
		for(j=0;j<m;j++)
			scanf("%d",&map[i][j]);
			
	memset(step,0,sizeof(step));
			
	for(i=0;i<n;i++)
		for(j=0;j<m;j++)
		{
			temp=dfs(i,j);
			if	(temp>maxx)
				maxx=temp;
		}
	printf("%d\n",maxx+1);
	
	return 0;
 } 
/*************************************************************************************************************/
/*
7.邮差送信 (15分) 
题目内容：
有一个邮递员要在n个城市之间来回送信。但有的城市之间有大路相连而有的没有路。
现在要由一个城市到另一个城市送信，中途最少要经过多少个其它的城市呢？
输入描述
第一行是n,k(1<=n<=10000, 1<=k<=20000)，接下来就是k行。这k行每行有两个数a,b(1<=a,b<= n)，表示城市a和b之间有大路k行以后就是两个数p和q。
输出描述
输出从城市p到城市q之间最少要经过的其它的城市的数目。如果p和q之间不连通则输出0
输入样例
6 6
1 4
1 2
2 3
3 4
5 4
5 6
1 6
输出样例
2
*/

#include<iostream>

using namespace std;

int a[100][100]; //存路径 
int far[100];    //求路径,即存储它的前一个结点 
int n, m, p, q;  //n个城市, m条路， p起点， q终点 
int z[1000];     //模拟队列 
int visit[100];  //标记是否访问过

void print(int w)
{
	int count=0;
	while(far[w]!=p)
	{
		count++;
		w=far[w];
	}
	
	cout<<count;-
	
}


void dfs()
{
	int head=1,tail=2;
	z[head]=p;
	visit[p]=1;
	int flag=1;
	while(head<tail&&flag)
	{
		for(int i=1;i<=n;i++)
		{
			if(a[z[head]][i]==1&&visit[i]==0)
			{
				visit[i]=1;
				z[tail]=i;
				tail++;
				far[i]=z[head];
				if(i==q)//找到退出 
				{
					flag=0;
					print(i);
					break;
				}
			}
		} 
		head++;
	}
	if(head==tail)//没有找到 
		cout<<0;
}

int main()
{
	cin>>n>>m;
	int x,y;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		a[x][y]=a[y][x]=1;
	}
	cin>>p>>q;
	dfs();
	return 0;
 } 
/*************************************************************************************************************/
/*************************************************************************************************************/
/*************************************************************************************************************/
