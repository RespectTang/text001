/*
9.穿越矩阵 (15分)
题目内容：
现在有一个 m * n 的整数矩阵，请你编写一个程序计算出一条从左到右穿过矩阵的路径，并使此路径的费用最小。
路径从矩阵的左侧的第一列的任意单元格开始，逐步穿过矩阵到达最右侧的一列的任意单元格。每一步是指从某单元
格进入它一列的相邻单元格（如下图，可以是横向或斜向）。矩阵的第一行和最后一行实际是相邻的，你可以想象矩阵
是包裹在一个横放的圆柱体外面（这点很重要）。 
路径的花费是指这条路径所穿越的所有单元格中的数字之和。
输入描述
输入包括一系列矩阵描述。每个矩阵描述的第一行是 m 和 n，即矩阵的行数和列数；之后的 m 行，每行包括 n 个以空
格分开的整数，则是当前矩阵的值，注意矩阵的值未必是正数。 
矩阵的行数 m 和列数 n 的范围是：1 <=m<=10、 1<=n<=100；所有路径的费用值都可以用 30bit 的整数表示。
输出描述
针对每一个矩阵，找出费用最小的路径，并将其输出。每个矩阵的输出包括两行，第一行是路径本身，即输出每一步所
在的行，第二行则是该路径的费用。 
如果对于同一个矩阵有多条不同的费用最小路径，则输出左端行号较小的一条。
输入样例
5 6
3 4 1 2 8 6
6 1 8 2 7 4
5 9 3 9 9 5
8 4 1 3 2 6
3 7 2 1 2 3
输出样例
1 2 1 5 4 5
11
*/ 

/*题解： 
乍一看像是搜索，但是其实是个dp的题。其实有了思路之后还是很好做的。
首先说顺序问题。如果是正序的话，很难确定应该是从哪一行开始找起，
即找到最后一列之后如果结果有相同的话还得再返回来，看看哪个才是左端行数最短的哪条，
这样就有些冗杂了。所以采用倒序，从后往前找，找到结果之后如果有相同的话直接看哪个左端行数最短即可。
然后就是循环，dp数组存当前点时候的ans，然后把所有的点都过一遍，
对于每个点而言是找右，右上，右下的值来确定这个点的结果。记得要考虑边界点时候的特殊情况。
遍历到最左端之后就有了min值，再一个一个返回去找，就找到了路径，然后记录一下每次的行数即可。
一开始错了一个地方，就是初始化的时候应该给dp数组初始化为0还是无穷大。初始化是0的话，
当只有一行的时候它更倾向于去加0而不是那一行的数，所以初始化的时候用INF。
*/ 
#include<stdio.h>
#include<string.h>
int dp[11][101],a[11][101],num[101]={0};
#define INF 0x3f3f3f3f
int min(int a,int b)
{	
	return a<b? a:b;
}	
int main()
{	
	int n,m;
	scanf("%d%d",&n,&m);
		memset(dp,INF,sizeof(dp));//初始化，将两个数组置0 
		memset(num,0,sizeof(num));
		for(int i=0;i<n;i++)
		for(int j=0;j<m;j++)
			scanf("%d",&a[i][j]);
		for(int i=0;i<n;i++)//初始化最后一列 
			dp[i][m-1]=a[i][m-1];
			
		for(int i=m-2;i>=0;i--)//从倒数第二列开始倒序寻找，并存储每一次的距离 
		for(int j=0;j<n;j++)
		{
			dp[j][i]=a[j][i];
			if(j>0&&j<n-1)//非第一列或最后一列的向下一列寻找 
				dp[j][i]+=min(min(dp[j][i+1],dp[j+1][i+1]),dp[j-1][i+1]);
			else if(j==0)//第一列向最后一列寻找 
				dp[j][i]+=min(min(dp[j][i+1],dp[j+1][i+1]),dp[n-1][i+1]);
			else if(j==n-1)//最后一列向第一列寻找 
				dp[j][i]+=min(min(dp[j][i+1],dp[0][i+1]),dp[j-1][i+1]);
		}
		
		int mini,mine=dp[n-1][0];
		for(int i=n-1;i>=0;i--)
		if(mine>=dp[i][0])//寻找从哪一列开始，并记录起点的最小值 
		{
			mine=dp[i][0];
			mini=i;
		}
		num[0]=mini;//num[0]记录起点最小值 
		
		for(int i=1;i<m;i++)//寻找其他最小值并用mine累加，用num数组记录位置 
		{
			int flag=0;
			for(int j=0;j<n;j++)
			{
				if(mini==0&&j!=0&&j!=1&&j!=n-1)
					continue;
				if(mini==n-1&&j!=n-1&&j!=n-2&&j!=0)
					continue;
				if(mini>0&&mini<n-1&&j!=mini&&j!=mini+1&&j!=mini-1)
					continue;
				if(dp[mini][i-1]-a[mini][i-1]==dp[j][i])
				{
					mini=j;
					num[i]=mini;
					flag=1;
				}
				if (flag)//找到最小值之后退出循环，进入下一列 
					break;
			}
		}
		printf("%d",num[0]+1);
		for(int i=1;i<m;i++)
			printf(" %d",num[i]+1);
		printf("\n%d\n",mine);
			
	return 0;
}
/****************************************************************************************************************************/
/*题目内容：
春天到了，花儿朵朵盛开，hrdv是一座大花园的主人，在他的花园里种着许多种鲜花，
每当这个时候，就会有一大群游客来他的花园欣赏漂亮的花朵，游客们总是会询问，
某个时间有多少种花儿同时在盛开着？hrdv虽然知道每种花儿的开花时间段，
但是他不能很快的答出游客的问题，你能编写一个程序帮助他吗？
输入描述
第一行有个整数t,表示有t组测试数据，每组测试数据第一行为两个整数n,m(0<n<100000，0<m<100000)，
表示有n种花;游客询问m个时间。随后有n行，每一行有两个整数x,y(0<x<y<1000000000)，
表示这一种花的盛开时间是从x到y；
随后有m行，每行有一个整数，代表游客询问的时间。

输出描述
对于每次游客的询问，输出一个整数在单独的一行，表示这个时间盛开的花有多少种。

输入样例
2                       //两组测试数据 
1 1                     //第一组数据：n==1，m==1 有一种花，游客询问一个时间 
5 10                    // x==5，y==10 这种花开的时间是5到10 
4                       //游客询问4的时候是否开花 
2 3                     //第二组数据，有两种花，游客询问三个时间 
1 4                     //开花时间1到4 
4 8						//开花时间4到8 
1                       //1、4、6时有几种花同时盛开 
4
6

输出样例
0
1
2
1
*/ 

#include<stdio.h>

int main() 
{
	int t,m,n,x,y,p,q,i,j,k,c=0;
	int b[1000]={0};	
	
	scanf("%d",&t);
	for(i=0;i<t;++i)
	{
		int a[1000]={0};

		scanf("%d%d",&n,&m);//n表示花的种数，m表示询问次数 

				for(j=0;j<n;++j)
			{
				scanf("%d%d",&x,&y);//表示开花区间为x到y 
				for(k=x;k<=y;k++)
					++a[k];//在这个开花区间内，从小到大依次记录数据出现的次数，出现一次+1 
			}
			
			for(int z=0;z<m;z++)//q表示准确的时间点 
			{
				scanf("%d",&p);
				
			//	printf("%dok\n",a[p]);
				b[c]=a[p];
				c++;
			}
	}
		for(q=0;q<c;q++)
		{
			printf("%d\n",b[q]);
		}

	
	return 0;
}
/****************************************************************************************************************************/
/*
8.数字三角形 (20分) 
C时间限制：3000 毫秒 |  C内存限制：3000 Kb
题目内容：
给定一个由n行数字组成的数字三角形，试设计一个算法，计算出从三角形的顶到底的一条路径，
使该路径经过的数字总和最大(输入时，这n行数字构成一个直角三角形，参见输入样例，计算路径时，
上面一个元素a只能选择下面一行中处于a正下方的b，或者b右边的元素c相连。反过来，
下面一个元素x,则只能跟正上面一个元素y, 或者y左边一个元素z相连）。
输入描述
第一行输入数字三角的行数n(0<n<100)，后面输入n行数字，每行元素个数递增,数据为100以内整数。
输出描述
输出最大值。
输入样例
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
输出样例
30
*/

#include<stdio.h>
int n;
int a[100][100];

int max(int p,int q)
{
	if(q>p)
	return q;
	else
	return p;
}

int m(int i,int j)
{
	int x,y;
	if(i==n)
		return a[i][j]; 

	x=m(i+1,j);
	y=m(i+1,j+1);
		return max(x,y)+a[i][j];
		
	
}

int main(int argc, char const *argv[])
{
	int i,j,k;
	
	scanf("%d",&n);
	
	for(i=1;i<=n;i++)
		for(j=1;j<=i;j++)
		{
			scanf("%d",&a[i][j]);
		}
		
	printf("%d",m(1,1));
	
	return 0;
}

/****************************************************************************************************************************/
