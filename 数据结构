/******************************************************************************************************************/
/*
1025. 反转链表 (25)
给定一个常数K以及一个单链表L，请编写程序将L中每K个结点反转。例如：给定L为1→2→3→4→5→6，K为3，
则输出应该为3→2→1→6→5→4；如果K为4，则输出应该为4→3→2→1→5→6，即最后不到K个元素不反转。
输入格式： 
每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址、结点总个数正整数N(<= 105)、以及正
整数K(<=N)，即要求反转的子链结点的个数。结点的地址是5位非负整数，NULL地址用-1表示。
接下来有N行，每行格式为：
Address Data Next
其中Address是结点地址，Data是该结点保存的整数数据，Next是下一结点的地址。
输出格式： 
对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。
输入样例：
00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218
输出样例：
00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1
*/ 
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstdio>
using namespace std;

struct Node{
	int address;
	int data;
	int next;
};
int main(){
    int N,first,K;
    vector<Node> shunxu;
    vector<Node> reverse;
    cin>>first>>N>>K;
    Node n;
    Node addr[100000];      //链表数组 
    for(int i=0;i<N;i++){
        cin>>n.address>>n.data>>n.next;
        addr[n.address]=n;  //将节点赋值到相应下标的位置 
    }
    int nextaddress=first;   
    while (nextaddress != -1){  //通过next作为下标寻找元素，添加到vector中，更新next继续寻找 
        shunxu.push_back(addr[nextaddress]); 
        nextaddress = addr[nextaddress].next;
    }
    int size=shunxu.size(); //输入的节点可能有些不在链表中，记录下链表的长度 
    int temp=K-1;
    while(temp<size){       //反转链表，每次翻转K个，不足K个不反转并退出循环 
        for(int i=temp;i>temp-K;i--){
            reverse.push_back(shunxu[i]);
        }
        temp+=K;
    }
    for(int i=temp-K+1;i<size;i++)//将最后没有反转的，复制到反转之后的链表 
        reverse.push_back(shunxu[i]);
    for(int i=0;i<size-1;i++){      //修改他们的next，改为下一个元素的address 
        reverse[i].next=reverse[i+1].address;
        printf("%05d %d %05d\n",reverse[i].address,reverse[i].data,reverse[i].next);  
    }
    printf("%05d %d %d\n",reverse[size-1].address,reverse[size-1].data,-1);

    return 0;
}
/*int main()
{
	int N,first,K;
	int i,j,k;
	vector<Node> shunxu;
	vector<Node> reverse;
	cin>>first>>N>>K;
	Node n;
	Node addr[100000];//建立链表数组
	 
	for(i=0;i<N;i++)
	{
		cin>>n.address >>n.data>>n.next ;
		addr[n.address]=n;//将节点赋值到地址的位置 
	}
	
	int nextaddress=first;
	while(nextaddress!=-1)//通过next作为下标来寻找元素，添加到vector中，不断更新next 
	{
		shunxu.push_back(addr[nextaddress]);
		nextaddress=addr[nextaddress].next;
	}
	int  size=shunxu.size();//输入的节点有可能不在链表中，记录链表长度
	int temp=K-1;
	while(temp<size)
	{
		for(i=temp;i>temp-K;i--)
		{
			reverse.push_back(shunxu[i]);	
		}
		temp+=k;
	 } 
	for(i=temp-K+1;i<size;i++)
	{
		reverse.push_back(shunxu[i]);//将最后没有反转的，复制到反转之后的链表		
	}
	for(i=0;i<size-1;i++)
	{
		reverse[i].next=reverse[i+1].address;//修改他们的next，改为下一个元素的address 
		printf("%05d %d %05d\n",reverse[i].address,reverse[i].data,reverse[i].next); 
	}
	printf("%05d %d %d\n",reverse[size-1].address,reverse[size-1].data,-1);

	return 0; 
}

*/
/******************************************************************************************************************/

/******************************************************************************************************************/
/******************************************************************************************************************/
/******************************************************************************************************************/
/******************************************************************************************************************/
