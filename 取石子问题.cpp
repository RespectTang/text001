/*题目内容：
有一堆石子，A，B两人轮流从中取出石子，每次取出的石子数目只能为1，3，7或8，最后一枚石子谁取到就是输方。
A,B两人都足够聪明，不会做出错误的判断。现给出一定数目的石子，A先取石子，计算A最终是输是赢，赢用1表示，
输用0表示.
输入描述
第一行为一个整数n(0< n <=100),表示玩n局，接下来n行每行有一个整数，表示对应的局提供的石子数（不大于
10000），
输出描述
编程输出A对应的n局是赢是输，赢输出1，输输出0.
输入样例
3
1
3
10
输出样例
0
0
1
*/


#include<stdio.h>
void fun(int a)
{
	int s[1000]={0};
	s[0]=0;
	s[1]=0;
	s[2]=1;
	s[3]=0;
	s[4]=1;
	s[5]=0;
	s[6]=1;
	s[7]=0;
	s[8]=1;
	for(int i=9;i<1000;i++)
	{
		if(s[i-1]==0||s[i-3]==0||s[i-7]==0||s[i-8]==0)
		s[i]=1;
		else
		s[i]=0;
		
	}
	printf("%d\n",s[a]); 
	
}

int main()
{
	int i,n,a[100];
	scanf("%d",&n);
	for(i=0;i<n;i++)
	{
		scanf("%d",&a[i]);
		fun(a[i]);
	}
		return 0;
}
/**********************************************************************************************/
/*
13.取牌比赛 (15分) 上面那个问题的改版解题关键在构造数组
C时间限制：3000?毫秒?|? C内存限制：3000?Kb
题目内容：
 两个人玩轮流取牌游戏，一共有M张牌，每次可以取1,2,或者5张，取到最后一张牌的人为胜利。编程判断先取牌的是否能胜利。
输入描述
牌数M
输出描述
Y或者N
输入样例
2
输出样例
Y
*/

#include<stdio.h>
void fun(int a)
{
	int s[1000]={0};
	s[0]=0;
	s[1]=1;
	s[2]=1;
	s[3]=0;
	s[4]=1;
	s[5]=1;
	s[6]=0;
	s[7]=1;
	s[8]=1;
	for(int i=9;i<1000;i++)
	{
		if(s[i-1]==0||s[i-2]==0||s[i-5]==0)
		s[i]=1;
		else
		s[i]=0;
		
	}
	if(s[a]==1) 
		printf("Y\n"); 
	else
		printf("N\n");
	
}

int main()
{
	int i,n,a[100];
		scanf("%d",&a[i]);
		fun(a[i]);
		return 0;
}
/**********************************************************************************************/
/*
取石子（三）
时间限制：1000 ms  |  内存限制：1000 KB
难度：6
描述
小王喜欢与同事玩一些小游戏，今天他们选择了玩取石子。
游戏规则如下：共有N堆石子，已知每堆中石子的数量，两个人轮流取子，每次只能选择N堆石子中的一堆，取一定数量的石子（最少取一个），
取过子之后，还可以将该堆石子中剩下的任意多个石子中随意选取几个放到其它的任意一堆或几堆上。等哪个人无法取子时就表示此人输掉了游戏。
注意，一堆石子没有子之后，就不能再往此处放石子了。
假设每次都是小王先取石子，并且游戏双方都绝对聪明，现在给你石子的堆数、每堆石子的数量，请判断出小王能否获胜。
例如：如果最开始有4堆石子，石子个数分别为3 1 4 2，而小王想决定要先拿走第三堆石子中的两个石子（石子堆状态变为3 1 2 2），
然后他可以使石子堆达到的状态有以下几种：
3 1 2 2（不再移动石子）
4 1 1 2（移动到第一堆一个）
3 2 1 2（移动到第二堆一个）
3 1 1 3（移动到第四堆一个）
5 1 0 2（全部移动到第一堆）
3 3 0 2（全部移动到第二堆）
3 1 0 4（全部移动到最后）

输入
可能有多组测试数据(测试数据组数不超过1000)
每组测试数据的第一行是一个整数，表示N(1<=N<=10)
第二行是N个整数分别表示该堆石子中石子的数量。（每堆石子数目不超过100）
当输入的N为0时，表示输入结束
输出
对于每组测试数据，输出Win表示小王可以获胜，输出Lose表示小王必然会败。
样例输入
3
2 1 3
2
1 1
0
样例输出
Win
Lose
思路(from baidu):
楼教主的男人八题之一， 必败局面是有偶数堆石子， 并且每种石子数量的的堆数都为偶数， 然后就可以跟着对手取，
 每次都把必败局面留给对手， 最后就会赢。每个非必败局都可以经过一次操作变为必败局。
*/

#include <stdio.h>  
#include <math.h>  
#include <string.h>  
int data[101];  
int main()  
{  
    int n, i, temp, flag;  
    while(scanf("%d", &n) && n)  
    {  
        flag = 0;  
        memset(data, 0, sizeof(data));  
        for(i = 0; i < n; i++)  
        {  
            scanf("%d", &temp);  
            data[temp]++;  
        }  
        for(i = 0; i < 101; i++)  
        {  
            if(data[i] % 2 == 1)  
            {  
                flag = 1;  
                break;  
            }  
        }  
        if(flag)  
        {  
            printf("Win\n");  
        }  
        else  
        {  
            printf("Lose\n");  
        }  
    }  
    return 0;  
}  

/**********************************************************************************************/
威佐夫博弈
/*
5.取石子 (15分)
题目内容：
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。
游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；
二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。
现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，
问最后你是胜者还是败者。
输入描述
输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，
表示两堆石子的数目，a和b都不大于1,000,000,000。
输出描述
输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。
输入样例
2 1
8 4
4 7
输出样例
0
1
0
*/
#include<stdio.h>
#include<math.h>
int main()
{
	int a,b,dif,i=0;
	int flag[100];
	double q;
	while(scanf("%d%d",&a,&b)!=EOF)
	{
		dif=a>b?a-b:b-a;
	//	dif=abs(a-b);//取差值 
		q=(sqrt((double)5)+1)/((double)2);//计算黄金分割数 
		a=a>b?b:a;//取较小的值 
		if(a==(int)(q*dif))//判断奇异局势
		flag[i]=0;
		else
		flag[i]=1; 
		i++;
	}
		for(int j=0;j<i;j++)
		printf("%d\n",flag[j]);
	return 0;
}



/**********************************************************************************************/
斐波那契博弈
/*
链接：https://www.nowcoder.com/acm/contest/77/G
来源：牛客网
题目描述
幼儿园开学了，为了让小盆友们能尽可能的多的享受假期。校长大人决定让小盆友分批到校，
至于每批学生来多少人由一个小傻子和一个小仙女负责，两个人轮番负责，校长会在最后的时候去查看工作进度，
小傻子不想被别人嘲笑自己傻，小仙女要证明自己比小傻子聪明。所以她们回去争抢安排最后一名小盆友。
每次安排的小盆友至少为1，至多为上一次安排的2倍。小仙女抢到了先手的机会。
第一次安排小盆友不能直接安排所有的小盆友一起回校。 
输入描述:
单组测试数据输入一个整数n——n代表小盆的个数（n>=2&&n<=1e9)
输出描述:
输出获胜人的名字——“Xian”或者“Sha”
示例1
输入
3
输出
Sha
*/ 

#include <iostream>
#include <cstdio>
 
 using namespace std;
 
 int f[50],n;
 
 bool find();
 
 int main(){
     f[0]=2;
     f[1]=3;
     for(int i=2;i<44;i++){//44是测试测出来的
         f[i]=f[i-1]+f[i-2];
     }
     scanf("%d",&n); 
         if(find())  puts("Sha");
         else    puts("Xian");

     return 0;
 }
 bool find(){
     int l=0,r=43,mid;
     while(l<=r){
         mid=(l+r)>>1;
         if(n==f[mid])   return true;
         else if(n<f[mid])   r=mid-1;
         else    l=mid+1;
     }
     return false;
 }

/**********************************************************************************************/
经典博弈
/*
题目内容：
 "有甲乙两个人玩取石子游戏,共有n个石子(1<=n<=30000)两个人轮流取,甲先取.
 每次最多取m个(1<=m<=30000)最少取一个,当轮到谁取的时候没有石子了,谁就赢.
比如4个石子,每次最多取3个,那末先取的人(甲)一定赢n和m谁大没有限制.)
(甲拿走3个,乙只拿走1个,下面轮到甲了,但是没有石子了,甲赢了．）
现在要求你写一个程序，输入n(总的石子个数），最多可以取的石子个数m，
输出甲（先取的人）是否会赢，会赢的话输出YES,否则输出LOSE.
我们这里假设甲乙两个人都采取最好的策略，也就是甲乙都非常想赢而且足够聪明．
比如输入11 4　输出LOSE"
输入描述
整数n m, 空格隔开
输出描述
YES或者LOSE
输入样例
11 4
输出样例
LOSE
*/
#include<stdio.h>
int main()
{
	int n,m;//总共n个石子，每次取m个 
	scanf("%d%d",&n,&m); 
	
	if((n==0)||(n==m+1)||(n%(m+1)==0))
		printf("YES");
	else
		printf("LOSE"); 
	
	return 0;
}
/**********************************************************************************************/
经典博弈加识别到文件未结束
#include<stdio.h>
#include<string.h>
#include<math.h>

int main()
{
	int m,n,i;
	for(i=1;1;i++)
	while(scanf("%d%d",&n,&m)!=EOF)	
		{
			if((n<=100000)&&(n>=1)&&(m>=1)&&(m<=100000))
			{
				if((n==m+1)||(n%(m+1)==0))
				{
					printf("case  %d:N\n",i);
					break;
				}
				else 
				{
					printf("case  %d:Y\n",i);	
					break;
				}
			
			}
            else 
            printf("输出错误"); 
		}	

	

	return 0;
}


